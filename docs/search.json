[{"path":"/articles/diagnosePPI.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"More Diagnostics for Projection Pursuit Indices","text":"vignette presents workflow built around functions: data_gen(), noise_gen(), ppi_mean(), ppi_scale(), ppi_noise_threshold() ppi_samplesize_effect()","code":"library(tidyverse) library(spinebil) library(tourr)"},{"path":"/articles/diagnosePPI.html","id":"packages","dir":"Articles","previous_headings":"","what":"Packages","title":"More Diagnostics for Projection Pursuit Indices","text":"","code":"library(tidyverse) library(spinebil) library(tourr)"},{"path":"/articles/diagnosePPI.html","id":"generating-synthetic-structures-and-noise","dir":"Articles","previous_headings":"","what":"1) Generating Synthetic Structures and Noise","title":"More Diagnostics for Projection Pursuit Indices","text":"data_gen(); generate structured 2D point sets (e.g., sine, circle, cluster) orthogonal polynomial features benchmarking/visualisation. Structures (type like \"sine\", \"circle\", …) return tibble columns x, y, structure. Polynomial (type = \"polynomial\") returns n × degree matrix orthogonal polynomial basis vectors [0,1]. noise_gen(); generates numeric vector noise values (tibble value type) distributions : \"gaussian\", \"uniform\", \"lognormal\", \"t_distributed\", \"cauchy\", \"beta_noise\", \"exponential\", \"microstructure\". ’ll preview available structures, create simple polynomial features, sample noise types, combine structure + noise. type: \"linear\", \"sine\", \"circle\", \"cluster\", \"snake\", \"outliers\", \"sparse\", \"clumpy\", \"skewed\", \"striated\", \"concave\", \"monotonic\", \"doughnut\", \"\", \"polynomial\". n: number points/samples. degree: \"polynomial\"; number basis columns. seed: optional seed reproducibility. n: number noise samples. type: distribution name ( \"gaussian\", \"uniform\", \"lognormal\", \"t_distributed\", \"cauchy\", \"beta_noise\", \"exponential\", \"microstructure\"). level: scale/strength noise. seed: optional seed.   simple example, let’s take clean sine wave add Gaussian noise y.  data_gen(\"polynomial\", ...) returns n × degree matrix. data_gen(<type>, ...) return tibble columns x, y, structure. noise_gen(...) returns tibble columns value (numeric) type (factor/character).","code":"data_gen(type = \"all\", n = 500, degree = NULL, seed = NULL) noise_gen(n = 500, type = \"gaussian\", level = 0.1, seed = NULL) # One structure df_sine <- data_gen(\"sine\", n = 400, seed = 1)  # Multiple structures at once df_all  <- data_gen(\"all\",  n = 400, seed = 1) ggplot(df_all, aes(x, y)) +   geom_point(alpha = 0.6, size = 0.6) +   facet_wrap(~ structure, scales = \"free\") +   labs(title = \"Synthetic 2D Structures from data_gen()\",        subtitle = \"Each panel generated with n = 400\") # Generate a 4-degree orthogonal polynomial basis dPoly <- data_gen(\"polynomial\", n = 200, degree = 4, seed = 1)  ggplot(dPoly, aes(x = dPoly[,1] , y = dPoly[,2])) +   geom_point(alpha = 0.7) +    xlab(\"polynomial degree 1\") +   ylab(\"polynomial degree 2\") eps_g <- noise_gen(n = 500, type = \"gaussian\",   level = 0.06, seed = 340) eps_t <- noise_gen(n = 500, type = \"t_distributed\", level = 0.15, seed = 341) eps_cau <- noise_gen(n = 500, type = \"cauchy\",     level = 0.04, seed = 342) set.seed(345) n <- 500 sine_clean <- data_gen(\"sine\", n = n) |> mutate(y = sin(x))   # Noise to add on y eps <- noise_gen(n = n, type = \"gaussian\", level = 0.06, seed = 123)$value sine_noisy <- sine_clean |> mutate(y = y + eps)  bind_rows(   sine_clean  |> mutate(which = \"clean\"),   sine_noisy  |> mutate(which = \"noisy (gaussian, level = 0.06)\") ) |>   ggplot(aes(x, y, color = which)) +   geom_point(alpha = 0.6, size = 0.6) +   labs(title = \"Sine Structure with and without Added Noise\",        color = NULL)"},{"path":"/articles/diagnosePPI.html","id":"function-usage","dir":"Articles","previous_headings":"","what":"Function usage","title":"More Diagnostics for Projection Pursuit Indices","text":"type: \"linear\", \"sine\", \"circle\", \"cluster\", \"snake\", \"outliers\", \"sparse\", \"clumpy\", \"skewed\", \"striated\", \"concave\", \"monotonic\", \"doughnut\", \"\", \"polynomial\". n: number points/samples. degree: \"polynomial\"; number basis columns. seed: optional seed reproducibility. n: number noise samples. type: distribution name ( \"gaussian\", \"uniform\", \"lognormal\", \"t_distributed\", \"cauchy\", \"beta_noise\", \"exponential\", \"microstructure\"). level: scale/strength noise. seed: optional seed.","code":"data_gen(type = \"all\", n = 500, degree = NULL, seed = NULL) noise_gen(n = 500, type = \"gaussian\", level = 0.1, seed = NULL)"},{"path":"/articles/diagnosePPI.html","id":"example-usage","dir":"Articles","previous_headings":"","what":"Example usage","title":"More Diagnostics for Projection Pursuit Indices","text":"","code":"# One structure df_sine <- data_gen(\"sine\", n = 400, seed = 1)  # Multiple structures at once df_all  <- data_gen(\"all\",  n = 400, seed = 1) ggplot(df_all, aes(x, y)) +   geom_point(alpha = 0.6, size = 0.6) +   facet_wrap(~ structure, scales = \"free\") +   labs(title = \"Synthetic 2D Structures from data_gen()\",        subtitle = \"Each panel generated with n = 400\") # Generate a 4-degree orthogonal polynomial basis dPoly <- data_gen(\"polynomial\", n = 200, degree = 4, seed = 1)  ggplot(dPoly, aes(x = dPoly[,1] , y = dPoly[,2])) +   geom_point(alpha = 0.7) +    xlab(\"polynomial degree 1\") +   ylab(\"polynomial degree 2\")"},{"path":"/articles/diagnosePPI.html","id":"preview-all-structures","dir":"Articles","previous_headings":"","what":"Preview all structures","title":"More Diagnostics for Projection Pursuit Indices","text":"","code":"ggplot(df_all, aes(x, y)) +   geom_point(alpha = 0.6, size = 0.6) +   facet_wrap(~ structure, scales = \"free\") +   labs(title = \"Synthetic 2D Structures from data_gen()\",        subtitle = \"Each panel generated with n = 400\")"},{"path":"/articles/diagnosePPI.html","id":"polynomial-features-type-polynomial","dir":"Articles","previous_headings":"","what":"Polynomial features (type = \"polynomial\")","title":"More Diagnostics for Projection Pursuit Indices","text":"","code":"# Generate a 4-degree orthogonal polynomial basis dPoly <- data_gen(\"polynomial\", n = 200, degree = 4, seed = 1)  ggplot(dPoly, aes(x = dPoly[,1] , y = dPoly[,2])) +   geom_point(alpha = 0.7) +    xlab(\"polynomial degree 1\") +   ylab(\"polynomial degree 2\")"},{"path":"/articles/diagnosePPI.html","id":"noise_gen-noise-distributions","dir":"Articles","previous_headings":"","what":"noise_gen(): noise distributions","title":"More Diagnostics for Projection Pursuit Indices","text":"","code":"eps_g <- noise_gen(n = 500, type = \"gaussian\",   level = 0.06, seed = 340) eps_t <- noise_gen(n = 500, type = \"t_distributed\", level = 0.15, seed = 341) eps_cau <- noise_gen(n = 500, type = \"cauchy\",     level = 0.04, seed = 342)"},{"path":"/articles/diagnosePPI.html","id":"combining-structure-noise","dir":"Articles","previous_headings":"","what":"Combining structure + noise","title":"More Diagnostics for Projection Pursuit Indices","text":"simple example, let’s take clean sine wave add Gaussian noise y.","code":"set.seed(345) n <- 500 sine_clean <- data_gen(\"sine\", n = n) |> mutate(y = sin(x))   # Noise to add on y eps <- noise_gen(n = n, type = \"gaussian\", level = 0.06, seed = 123)$value sine_noisy <- sine_clean |> mutate(y = y + eps)  bind_rows(   sine_clean  |> mutate(which = \"clean\"),   sine_noisy  |> mutate(which = \"noisy (gaussian, level = 0.06)\") ) |>   ggplot(aes(x, y, color = which)) +   geom_point(alpha = 0.6, size = 0.6) +   labs(title = \"Sine Structure with and without Added Noise\",        color = NULL)"},{"path":"/articles/diagnosePPI.html","id":"return-value","dir":"Articles","previous_headings":"","what":"Return value","title":"More Diagnostics for Projection Pursuit Indices","text":"data_gen(\"polynomial\", ...) returns n × degree matrix. data_gen(<type>, ...) return tibble columns x, y, structure. noise_gen(...) returns tibble columns value (numeric) type (factor/character).","code":""},{"path":"/articles/diagnosePPI.html","id":"finding-projection-pursuit-index-mean","dir":"Articles","previous_headings":"","what":"2) Finding Projection Pursuit Index Mean","title":"More Diagnostics for Projection Pursuit Indices","text":"ppi_mean() simulates summarizes projection pursuit index (PPI) 2D variable pairs dataset. pair, repeats index evaluation n_sim times (sampling n_obs observations time) returns mean index per pair. tibble one row per variable pair: var_i, var_j; names variables forming pair. mean_index; mean index across n_sim simulations pair.","code":"res <- ppi_mean(   data,        # data frame with ≥ 2 numeric columns   index_fun,   # function taking n×2 matrix and returning a numeric value   n_sim = 100,   n_obs = 300 ) data <- as.data.frame(data_gen(type = \"polynomial\", degree = 2)) res  <- ppi_mean(data, scagIndex(\"stringy\"), n_sim = 5) res #> # A tibble: 1 × 3 #>   var_i var_j mean_index #>   <chr> <chr>      <dbl> #> 1 1     2              1"},{"path":"/articles/diagnosePPI.html","id":"function-usage-1","dir":"Articles","previous_headings":"","what":"Function usage","title":"More Diagnostics for Projection Pursuit Indices","text":"","code":"res <- ppi_mean(   data,        # data frame with ≥ 2 numeric columns   index_fun,   # function taking n×2 matrix and returning a numeric value   n_sim = 100,   n_obs = 300 )"},{"path":"/articles/diagnosePPI.html","id":"example-usage-1","dir":"Articles","previous_headings":"","what":"Example Usage","title":"More Diagnostics for Projection Pursuit Indices","text":"","code":"data <- as.data.frame(data_gen(type = \"polynomial\", degree = 2)) res  <- ppi_mean(data, scagIndex(\"stringy\"), n_sim = 5) res #> # A tibble: 1 × 3 #>   var_i var_j mean_index #>   <chr> <chr>      <dbl> #> 1 1     2              1"},{"path":"/articles/diagnosePPI.html","id":"return-value-1","dir":"Articles","previous_headings":"","what":"Return value","title":"More Diagnostics for Projection Pursuit Indices","text":"tibble one row per variable pair: var_i, var_j; names variables forming pair. mean_index; mean index across n_sim simulations pair.","code":""},{"path":"/articles/diagnosePPI.html","id":"comparing-index-scale-on-structured-vs--noisy-data","dir":"Articles","previous_headings":"","what":"3) Comparing Index Scale on Structured vs. Noisy Data","title":"More Diagnostics for Projection Pursuit Indices","text":"ppi_scale() runs simulations compare projection pursuit index (PPI) : Structured dataset (input), Pure Gaussian noise (sample size). every pair variables across many simulations, records index values cases can see scale separation index structure noise.","code":""},{"path":"/articles/diagnosePPI.html","id":"function-usage-2","dir":"Articles","previous_headings":"","what":"Function Usage","title":"More Diagnostics for Projection Pursuit Indices","text":"Inputs: data — data frame/tibble/matrix; (>= 2 numeric columns). index_fun — function: takes 2-column matrix returns numeric scalar (e.g., scagIndex(\"stringy\")). n_sim — number simulations. n_obs — number observations. seed — optional seed reproducibility.","code":"ppi_scale(   data,           index_fun,    n_sim = 100,   n_obs = 500,   seed = NULL )"},{"path":"/articles/diagnosePPI.html","id":"example-usage-2","dir":"Articles","previous_headings":"","what":"Example usage","title":"More Diagnostics for Projection Pursuit Indices","text":"Let’s evaluate stringy index cassowaryr package see scale change pure noise structure. sigma = 0 structured sigma = 1 pure noise.","code":"res <- ppi_scale(data_gen(\"polynomial\", degree = 3), scagIndex(\"stringy\"), n_sim = 3)  head(res) #> # A tibble: 6 × 6 #>   simulation var_i var_j var_pair sigma index #>        <int> <chr> <chr> <chr>    <dbl> <dbl> #> 1          1 1     2     1-2          0 1     #> 2          1 1     2     1-2          1 0.732 #> 3          1 1     3     1-3          0 1     #> 4          1 1     3     1-3          1 0.783 #> 5          1 2     3     2-3          0 0.996 #> 6          1 2     3     2-3          1 0.719 res %>%   mutate(sigma = factor(sigma, levels = c(0,1), labels = c(\"structured\",\"noise\"))) %>%   ggplot(aes(x = sigma, y = index, fill = sigma)) +   geom_boxplot() +   facet_wrap(~ var_pair, scales = \"free_y\") +   labs(     title = \"Index scale on structured vs noisy data\",     x = NULL, y = \"index\"   )"},{"path":"/articles/diagnosePPI.html","id":"boxplots-structured-vs-noise-per-variable-pair","dir":"Articles","previous_headings":"","what":"Boxplots: structured vs noise per variable pair","title":"More Diagnostics for Projection Pursuit Indices","text":"","code":"res %>%   mutate(sigma = factor(sigma, levels = c(0,1), labels = c(\"structured\",\"noise\"))) %>%   ggplot(aes(x = sigma, y = index, fill = sigma)) +   geom_boxplot() +   facet_wrap(~ var_pair, scales = \"free_y\") +   labs(     title = \"Index scale on structured vs noisy data\",     x = NULL, y = \"index\"   )"},{"path":"/articles/diagnosePPI.html","id":"return-value-2","dir":"Articles","previous_headings":"","what":"Return value","title":"More Diagnostics for Projection Pursuit Indices","text":"ppi_scale() returns tibble columns: simulation: simulation index var_i, var_j: two variable names var_pair: \"var_i-var_j\" compact label. Structured value (sigma = 0); compute index actual pair. Noise value (sigma = 1); generate n_obs standard-normal x, y, scale mean 0 / sd 1, compute index. index: index value index_fun.","code":""},{"path":"/articles/diagnosePPI.html","id":"estimating-a-noise-threshold-for-projectionpursuit-indices","dir":"Articles","previous_headings":"","what":"4) Estimating a Noise Threshold for Projection–Pursuit Indices","title":"More Diagnostics for Projection Pursuit Indices","text":"ppi_noise_threshold() estimates 95th percentile projection pursuit index (PPI) synthetic noise. gives null threshold: observed index real data exceeds value, may indicate non-random structure. function supports different noise types via noise_gen() (e.g., Gaussian, tt-distributed, Cauchy, microstructure) lets set number simulations sample size per simulation.","code":""},{"path":"/articles/diagnosePPI.html","id":"function-usage-3","dir":"Articles","previous_headings":"","what":"Function usage","title":"More Diagnostics for Projection Pursuit Indices","text":"Inputs : index_fun: function returns single numeric value. n_sim: number simulations. n_obs: sample size per simulation. noise_type / noise_level: passed noise_gen() control distribution scale. seed: reproducibility.","code":"ppi_noise_threshold(   index_fun,   n_sim = 100,   n_obs = 500,   noise_type  = \"gaussian\",   noise_level = 0.01,   seed = NULL )"},{"path":"/articles/diagnosePPI.html","id":"example-usage-3","dir":"Articles","previous_headings":"","what":"Example Usage","title":"More Diagnostics for Projection Pursuit Indices","text":"","code":"thr <- ppi_noise_threshold(   index_fun   = scagIndex(\"stringy\"),   noise_type  = \"cauchy\",   noise_level = 0.1,   n_sim       = 10,   n_obs       = 100 ) thr #>       95%  #> 0.7865055"},{"path":"/articles/diagnosePPI.html","id":"return-value-3","dir":"Articles","previous_headings":"","what":"Return value","title":"More Diagnostics for Projection Pursuit Indices","text":"ppi_noise_threshold() returns single numeric: estimated 95th percentile index specified noise model.","code":""},{"path":"/articles/diagnosePPI.html","id":"sample-size-effects-for-projection-pursuit-indexes-under-gaussian-noise","dir":"Articles","previous_headings":"","what":"5) Sample-Size Effects for Projection Pursuit Indexes under Gaussian Noise","title":"More Diagnostics for Projection Pursuit Indices","text":"demonstrates use ppi_samplesize_effect() function study projection pursuit index (PPI) values behave increasing sample sizes purely noisy (Gaussian) data. size, computes specified index function samples records 95th percentile index values observed. helps estimate distributional behavior index pure noise, depending sample size. curves useful null reference: -curve values may indicate non-random structure.","code":""},{"path":"/articles/diagnosePPI.html","id":"function-usage-4","dir":"Articles","previous_headings":"","what":"Function Usage","title":"More Diagnostics for Projection Pursuit Indices","text":"index_fun: function accepts data one simulation returns single numeric index value. n_sim: number simulations per sample size (default 100). Internally, function evaluates grid sample sizes 30 2000 (denser small sizes), simulates n_sim draws , returns 95th percentile resulting index values.","code":"ppi_samplesize_effect(index_fun, n_sim = 100)"},{"path":"/articles/diagnosePPI.html","id":"example-usage-4","dir":"Articles","previous_headings":"","what":"Example Usage","title":"More Diagnostics for Projection Pursuit Indices","text":"Let’s evaluate stringy index cassowaryr package see values change noise sample size increases.","code":"result <- ppi_samplesize_effect(scagIndex(\"stringy\"), n_sim = 4) head(result) #> # A tibble: 6 × 2 #>   SampleSize Percentile95 #>        <dbl>        <dbl> #> 1         30        0.816 #> 2         35        0.752 #> 3         40        0.832 #> 4         45        0.758 #> 5         50        0.815 #> 6         55        0.800 tail(result) #> # A tibble: 6 × 2 #>   SampleSize Percentile95 #>        <dbl>        <dbl> #> 1       1875        0.739 #> 2       1900        0.744 #> 3       1925        0.736 #> 4       1950        0.737 #> 5       1975        0.731 #> 6       2000        0.736 ggplot(result, aes(SampleSize, Percentile95)) +   geom_point(alpha = 0.7, size = 1) +   geom_smooth(se = FALSE, method = \"loess\", formula = y ~ x, span = 0.1) +   labs(     x = \"Sample size (n)\",     y = \"95th percentile of index\"   )"},{"path":"/articles/diagnosePPI.html","id":"plot-the-95th-percentile","dir":"Articles","previous_headings":"","what":"Plot the 95th-percentile","title":"More Diagnostics for Projection Pursuit Indices","text":"","code":"ggplot(result, aes(SampleSize, Percentile95)) +   geom_point(alpha = 0.7, size = 1) +   geom_smooth(se = FALSE, method = \"loess\", formula = y ~ x, span = 0.1) +   labs(     x = \"Sample size (n)\",     y = \"95th percentile of index\"   )"},{"path":"/articles/diagnosePPI.html","id":"return-value-4","dir":"Articles","previous_headings":"","what":"Return value","title":"More Diagnostics for Projection Pursuit Indices","text":"ppi_samplesize_effect() returns tibble: SampleSize: sample size block simulations Percentile95: empirical 95th percentile index across n_sim simulations size.","code":""},{"path":"/articles/indexMean.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Simulate and Summarize Projection Pursuit Index (PPI) Means","text":"ppi_mean() simulates summarizes projection pursuit index (PPI) 2D variable pairs dataset. pair, repeats index evaluation n_sim times (sampling n_obs observations time) returns mean index per pair.","code":"library(spinebil)"},{"path":"/articles/indexMean.html","id":"what-the-function-does","dir":"Articles","previous_headings":"","what":"What the Function Does","title":"Simulate and Summarize Projection Pursuit Index (PPI) Means","text":"ppi_mean(data, index_fun, n_sim = 100, n_obs = 300) Builds 2-column variable pairs data. simulation (1,…,n_sim) pair (x, y), computes index via index_fun. Aggregates mean index per pair.","code":""},{"path":"/articles/indexMean.html","id":"function-usage","dir":"Articles","previous_headings":"","what":"Function usage","title":"Simulate and Summarize Projection Pursuit Index (PPI) Means","text":"","code":"res <- ppi_mean(   data,        # data frame with ≥ 2 numeric columns   index_fun,   #function taking n×2 matrix and returning a numeric value   n_sim = 100,   n_obs = 300 )"},{"path":"/articles/indexMean.html","id":"example-usage","dir":"Articles","previous_headings":"","what":"Example Usage","title":"Simulate and Summarize Projection Pursuit Index (PPI) Means","text":"","code":"data <- as.data.frame(data_gen(type = \"polynomial\", degree = 2)) res  <- ppi_mean(data, scagIndex(\"stringy\"), n_sim = 5) res #> # A tibble: 1 × 3 #>   var_i var_j mean_index #>   <chr> <chr>      <dbl> #> 1 1     2              1"},{"path":"/articles/indexMean.html","id":"return-value","dir":"Articles","previous_headings":"","what":"Return value","title":"Simulate and Summarize Projection Pursuit Index (PPI) Means","text":"tibble one row per variable pair: var_i, var_j — names variables forming pair. mean_index — mean index across n_sim simulations pair.","code":""},{"path":"/articles/indexNoiseThreshold.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Estimating a Noise Threshold for Projection–Pursuit Indices","text":"ppi_noise_threshold() estimates 95th percentile projection pursuit index (PPI) synthetic noise. gives null threshold: observed index real data exceeds value, may indicate non-random structure. function supports different noise types via noise_gen() (e.g., Gaussian, tt-distributed, Cauchy, microstructure) lets set number simulations sample size per simulation.","code":"library(tidyverse) library(spinebil)"},{"path":"/articles/indexNoiseThreshold.html","id":"what-the-function-does","dir":"Articles","previous_headings":"","what":"What the Function Does","title":"Estimating a Noise Threshold for Projection–Pursuit Indices","text":"ppi_noise_threshold(index_fun, n_sim = 100, n_obs = 500, noise_type = \"gaussian\", noise_level = 0.01, seed = NULL) Generates noise pairs (x, y) repeatedly (n_sim times), length n_obs, using noise_gen(type = noise_type, level = noise_level). Computes index every simulated pair via index_fun. Returns 95th percentile (quantile(..., 0.95)) simulated index values.","code":""},{"path":"/articles/indexNoiseThreshold.html","id":"function-usage","dir":"Articles","previous_headings":"","what":"Function usage","title":"Estimating a Noise Threshold for Projection–Pursuit Indices","text":"Arguments : index_fun: function returns single numeric value. n_sim: number simulations. n_obs: sample size per simulation. noise_type / noise_level: passed noise_gen() control distribution scale. seed: reproducibility.","code":"ppi_noise_threshold(   index_fun,   n_sim = 100,   n_obs = 500,   noise_type  = \"gaussian\",   noise_level = 0.01,   seed = NULL )"},{"path":"/articles/indexNoiseThreshold.html","id":"example-usage","dir":"Articles","previous_headings":"","what":"Example Usage","title":"Estimating a Noise Threshold for Projection–Pursuit Indices","text":"","code":"thr <- ppi_noise_threshold(   index_fun   = scagIndex(\"stringy\"),   noise_type  = \"cauchy\",   noise_level = 0.1,   n_sim       = 10,   n_obs       = 100 ) thr #>       95%  #> 0.7483209"},{"path":"/articles/indexNoiseThreshold.html","id":"return-value","dir":"Articles","previous_headings":"","what":"Return value","title":"Estimating a Noise Threshold for Projection–Pursuit Indices","text":"ppi_noise_threshold() returns single numeric: estimated 95th percentile index specified noise model.","code":""},{"path":"/articles/indexScale.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Comparing Index Scale on Structured vs. Noisy Data","text":"ppi_scale() runs simulations compare projection pursuit index (PPI) : Structured dataset (input), Pure Gaussian noise (sample size). every pair variables across many simulations, records index values cases can see scale separation index structure noise.","code":"library(spinebil)  library(tidyverse)"},{"path":"/articles/indexScale.html","id":"what-the-function-does","dir":"Articles","previous_headings":"","what":"What the Function Does","title":"Comparing Index Scale on Structured vs. Noisy Data","text":"Pairs: builds 2D variable pairs data. Simulations: simulation 1,...,n_sim pair: Structured value (sigma = 0) — compute index actual pair. Noise value (sigma = 1) — generate n_obs standard-normal x, y, scale mean 0 / sd 1, compute index. Output: tidy table simulation id, variable pair, sigma ∈ {0,1}, index value.","code":""},{"path":"/articles/indexScale.html","id":"ppi_scaledata-index_fun-n_sim-100-n_obs-500-seed-null","dir":"Articles","previous_headings":"","what":"ppi_scale(data, index_fun, n_sim = 100, n_obs = 500, seed = NULL)","title":"Comparing Index Scale on Structured vs. Noisy Data","text":"Pairs: builds 2D variable pairs data. Simulations: simulation 1,...,n_sim pair: Structured value (sigma = 0) — compute index actual pair. Noise value (sigma = 1) — generate n_obs standard-normal x, y, scale mean 0 / sd 1, compute index. Output: tidy table simulation id, variable pair, sigma ∈ {0,1}, index value.","code":""},{"path":"/articles/indexScale.html","id":"function-usage","dir":"Articles","previous_headings":"","what":"Function usage","title":"Comparing Index Scale on Structured vs. Noisy Data","text":"Arguments: data — data frame/tibble/matrix; (>= 2 numeric columns). index_fun — function: takes 2-column matrix returns numeric scalar (e.g., scagIndex(\"stringy\")). n_sim — number simulations. n_obs — number observations. seed — optional seed reproducibility.","code":"ppi_scale(   data,           index_fun,    n_sim = 100,   n_obs = 500,   seed = NULL )"},{"path":"/articles/indexScale.html","id":"example-usage","dir":"Articles","previous_headings":"","what":"Example usage","title":"Comparing Index Scale on Structured vs. Noisy Data","text":"Let’s evaluate stringy index cassowaryr package see scale change pure noise structure. sigma = 0 structured sigma = 1 pure noise.","code":"res <- ppi_scale(data_gen(\"polynomial\", degree = 3), scagIndex(\"stringy\"), n_sim = 3)  head(res) #> # A tibble: 6 × 6 #>   simulation var_i var_j var_pair sigma index #>        <int> <chr> <chr> <chr>    <dbl> <dbl> #> 1          1 1     2     1-2          0 1     #> 2          1 1     2     1-2          1 0.739 #> 3          1 1     3     1-3          0 1     #> 4          1 1     3     1-3          1 0.732 #> 5          1 2     3     2-3          0 0.996 #> 6          1 2     3     2-3          1 0.735 res %>%   mutate(sigma = factor(sigma, levels = c(0,1), labels = c(\"structured\",\"noise\"))) %>%   ggplot(aes(x = sigma, y = index, fill = sigma)) +   geom_boxplot() +   facet_wrap(~ var_pair, scales = \"free_y\") +   labs(     title = \"Index scale on structured vs noisy data\",     x = NULL, y = \"index\"   )"},{"path":"/articles/indexScale.html","id":"boxplots-structured-vs-noise-per-variable-pair","dir":"Articles","previous_headings":"","what":"Boxplots: structured vs noise per variable pair","title":"Comparing Index Scale on Structured vs. Noisy Data","text":"","code":"res %>%   mutate(sigma = factor(sigma, levels = c(0,1), labels = c(\"structured\",\"noise\"))) %>%   ggplot(aes(x = sigma, y = index, fill = sigma)) +   geom_boxplot() +   facet_wrap(~ var_pair, scales = \"free_y\") +   labs(     title = \"Index scale on structured vs noisy data\",     x = NULL, y = \"index\"   )"},{"path":"/articles/indexScale.html","id":"return-value","dir":"Articles","previous_headings":"","what":"Return value","title":"Comparing Index Scale on Structured vs. Noisy Data","text":"ppi_scale() returns tibble columns: simulation: simulation index var_i, var_j: two variable names var_pair: \"var_i-var_j\" compact label. sigma: 0 = structured, 1 = noise index: index value index_fun","code":""},{"path":"/articles/more_descriptives.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"More Descriptive Analysis of Projection Pursuit Indices","text":"vignette presents workflow built around functions: data_gen(), noise_gen(), ppi_mean(), ppi_scale(), ppi_noise_threshold() ppi_samplesize_effect().","code":""},{"path":"/articles/more_descriptives.html","id":"generating-synthetic-structures-and-noise","dir":"Articles","previous_headings":"","what":"1) Generating Synthetic Structures and Noise","title":"More Descriptive Analysis of Projection Pursuit Indices","text":"data_gen(); generate structured 2D point sets (e.g., sine, circle, cluster) orthogonal polynomial features benchmarking/visualisation. Structures (type like \"sine\", \"circle\", …) return tibble columns x, y, structure. Polynomial (type = \"polynomial\") returns n × degree matrix orthogonal polynomial basis vectors [0,1]. noise_gen(); generates numeric vector noise values (tibble value type) distributions : \"gaussian\", \"uniform\", \"lognormal\", \"t_distributed\", \"cauchy\", \"beta_noise\", \"exponential\", \"microstructure\". ’ll preview available structures, create simple polynomial features, sample noise types, combine structure + noise. type: \"linear\", \"sine\", \"circle\", \"cluster\", \"snake\", \"outliers\", \"sparse\", \"clumpy\", \"skewed\", \"striated\", \"concave\", \"monotonic\", \"doughnut\", \"\", \"polynomial\". n: number points/samples. degree: \"polynomial\"; number basis columns. seed: optional seed reproducibility. n: number noise samples. type: distribution name ( \"gaussian\", \"uniform\", \"lognormal\", \"t_distributed\", \"cauchy\", \"beta_noise\", \"exponential\", \"microstructure\"). level: scale/strength noise. seed: optional seed.   simple example, let’s take clean sine wave add Gaussian noise y.  data_gen(\"polynomial\", ...) returns n × degree matrix. data_gen(<type>, ...) return tibble columns x, y, structure. noise_gen(...) returns tibble columns value (numeric) type (factor/character).","code":"data_gen(type = \"all\", n = 500, degree = NULL, seed = NULL) noise_gen(n = 500, type = \"gaussian\", level = 0.1, seed = NULL) # One structure df_sine <- spinebil::data_gen(\"sine\", n = 400, seed = 1)  # Multiple structures at once df_all <- spinebil::data_gen(\"all\", n = 400, seed = 1) ggplot2::ggplot(df_all, ggplot2::aes(x, y)) +   ggplot2::geom_point(alpha = 0.6, size = 0.6) +   ggplot2::facet_wrap(~structure) +   ggplot2::labs(     title = \"Synthetic 2D Structures from dataGen()\",     subtitle = \"Each panel generated with n = 400\"   ) +   ggplot2::xlim(-1.5, 1.5) +   ggplot2::ylim(-1.5, 1.5) +   ggplot2::theme(     axis.text = ggplot2::element_blank(),     axis.title = ggplot2::element_blank(),     axis.ticks = ggplot2::element_blank()   ) # Generate a 4-degree orthogonal polynomial basis dPoly <- spinebil::data_gen(\"polynomial\", n = 200, degree = 4, seed = 1)  ggplot2::ggplot(dPoly, ggplot2::aes(x = dPoly[, 1], y = dPoly[, 2])) +   ggplot2::geom_point(alpha = 0.7) +   ggplot2::xlab(\"polynomial degree 1\") +   ggplot2::ylab(\"polynomial degree 2\") +   ggplot2::theme(     aspect.ratio = 1,     axis.text = ggplot2::element_blank(),     axis.ticks = ggplot2::element_blank()   ) eps_g <- spinebil::noise_gen(n = 500, type = \"gaussian\", level = 0.06, seed = 340) eps_t <- spinebil::noise_gen(n = 500, type = \"t_distributed\", level = 0.15, seed = 341) eps_cau <- spinebil::noise_gen(n = 500, type = \"cauchy\", level = 0.04, seed = 342) set.seed(345) n <- 500 sine_clean <- spinebil::data_gen(\"sine\", n = n) |> dplyr::mutate(y = sin(x))  # Noise to add on y eps <- spinebil::noise_gen(n = n, type = \"gaussian\", level = 0.06, seed = 123)$value sine_noisy <- sine_clean |> dplyr::mutate(y = y + eps)  dplyr::bind_rows(   sine_clean |> dplyr::mutate(which = \"clean\"),   sine_noisy |> dplyr::mutate(which = \"noisy (gaussian, level = 0.06)\") ) |>   ggplot2::ggplot(ggplot2::aes(x, y, color = which)) +   ggplot2::geom_point(alpha = 0.6, size = 0.6) +   ggplot2::labs(     title = \"Sine Structure with and without Added Noise\",     color = NULL   ) +   ggplot2::theme(     axis.text = ggplot2::element_blank(),     axis.title = ggplot2::element_blank(),     axis.ticks = ggplot2::element_blank()   )"},{"path":"/articles/more_descriptives.html","id":"function-usage","dir":"Articles","previous_headings":"","what":"Function usage","title":"More Descriptive Analysis of Projection Pursuit Indices","text":"type: \"linear\", \"sine\", \"circle\", \"cluster\", \"snake\", \"outliers\", \"sparse\", \"clumpy\", \"skewed\", \"striated\", \"concave\", \"monotonic\", \"doughnut\", \"\", \"polynomial\". n: number points/samples. degree: \"polynomial\"; number basis columns. seed: optional seed reproducibility. n: number noise samples. type: distribution name ( \"gaussian\", \"uniform\", \"lognormal\", \"t_distributed\", \"cauchy\", \"beta_noise\", \"exponential\", \"microstructure\"). level: scale/strength noise. seed: optional seed.","code":"data_gen(type = \"all\", n = 500, degree = NULL, seed = NULL) noise_gen(n = 500, type = \"gaussian\", level = 0.1, seed = NULL)"},{"path":"/articles/more_descriptives.html","id":"example-usage","dir":"Articles","previous_headings":"","what":"Example usage","title":"More Descriptive Analysis of Projection Pursuit Indices","text":"","code":"# One structure df_sine <- spinebil::data_gen(\"sine\", n = 400, seed = 1)  # Multiple structures at once df_all <- spinebil::data_gen(\"all\", n = 400, seed = 1) ggplot2::ggplot(df_all, ggplot2::aes(x, y)) +   ggplot2::geom_point(alpha = 0.6, size = 0.6) +   ggplot2::facet_wrap(~structure) +   ggplot2::labs(     title = \"Synthetic 2D Structures from dataGen()\",     subtitle = \"Each panel generated with n = 400\"   ) +   ggplot2::xlim(-1.5, 1.5) +   ggplot2::ylim(-1.5, 1.5) +   ggplot2::theme(     axis.text = ggplot2::element_blank(),     axis.title = ggplot2::element_blank(),     axis.ticks = ggplot2::element_blank()   ) # Generate a 4-degree orthogonal polynomial basis dPoly <- spinebil::data_gen(\"polynomial\", n = 200, degree = 4, seed = 1)  ggplot2::ggplot(dPoly, ggplot2::aes(x = dPoly[, 1], y = dPoly[, 2])) +   ggplot2::geom_point(alpha = 0.7) +   ggplot2::xlab(\"polynomial degree 1\") +   ggplot2::ylab(\"polynomial degree 2\") +   ggplot2::theme(     aspect.ratio = 1,     axis.text = ggplot2::element_blank(),     axis.ticks = ggplot2::element_blank()   )"},{"path":"/articles/more_descriptives.html","id":"preview-all-structures","dir":"Articles","previous_headings":"","what":"Preview all structures","title":"More Descriptive Analysis of Projection Pursuit Indices","text":"","code":"ggplot2::ggplot(df_all, ggplot2::aes(x, y)) +   ggplot2::geom_point(alpha = 0.6, size = 0.6) +   ggplot2::facet_wrap(~structure) +   ggplot2::labs(     title = \"Synthetic 2D Structures from dataGen()\",     subtitle = \"Each panel generated with n = 400\"   ) +   ggplot2::xlim(-1.5, 1.5) +   ggplot2::ylim(-1.5, 1.5) +   ggplot2::theme(     axis.text = ggplot2::element_blank(),     axis.title = ggplot2::element_blank(),     axis.ticks = ggplot2::element_blank()   )"},{"path":"/articles/more_descriptives.html","id":"polynomial-features-type-polynomial","dir":"Articles","previous_headings":"","what":"Polynomial features (type = \"polynomial\")","title":"More Descriptive Analysis of Projection Pursuit Indices","text":"","code":"# Generate a 4-degree orthogonal polynomial basis dPoly <- spinebil::data_gen(\"polynomial\", n = 200, degree = 4, seed = 1)  ggplot2::ggplot(dPoly, ggplot2::aes(x = dPoly[, 1], y = dPoly[, 2])) +   ggplot2::geom_point(alpha = 0.7) +   ggplot2::xlab(\"polynomial degree 1\") +   ggplot2::ylab(\"polynomial degree 2\") +   ggplot2::theme(     aspect.ratio = 1,     axis.text = ggplot2::element_blank(),     axis.ticks = ggplot2::element_blank()   )"},{"path":"/articles/more_descriptives.html","id":"noise_gen-noise-distributions","dir":"Articles","previous_headings":"","what":"noise_gen(): noise distributions","title":"More Descriptive Analysis of Projection Pursuit Indices","text":"","code":"eps_g <- spinebil::noise_gen(n = 500, type = \"gaussian\", level = 0.06, seed = 340) eps_t <- spinebil::noise_gen(n = 500, type = \"t_distributed\", level = 0.15, seed = 341) eps_cau <- spinebil::noise_gen(n = 500, type = \"cauchy\", level = 0.04, seed = 342)"},{"path":"/articles/more_descriptives.html","id":"combining-structure-noise","dir":"Articles","previous_headings":"","what":"Combining structure + noise","title":"More Descriptive Analysis of Projection Pursuit Indices","text":"simple example, let’s take clean sine wave add Gaussian noise y.","code":"set.seed(345) n <- 500 sine_clean <- spinebil::data_gen(\"sine\", n = n) |> dplyr::mutate(y = sin(x))  # Noise to add on y eps <- spinebil::noise_gen(n = n, type = \"gaussian\", level = 0.06, seed = 123)$value sine_noisy <- sine_clean |> dplyr::mutate(y = y + eps)  dplyr::bind_rows(   sine_clean |> dplyr::mutate(which = \"clean\"),   sine_noisy |> dplyr::mutate(which = \"noisy (gaussian, level = 0.06)\") ) |>   ggplot2::ggplot(ggplot2::aes(x, y, color = which)) +   ggplot2::geom_point(alpha = 0.6, size = 0.6) +   ggplot2::labs(     title = \"Sine Structure with and without Added Noise\",     color = NULL   ) +   ggplot2::theme(     axis.text = ggplot2::element_blank(),     axis.title = ggplot2::element_blank(),     axis.ticks = ggplot2::element_blank()   )"},{"path":"/articles/more_descriptives.html","id":"return-value","dir":"Articles","previous_headings":"","what":"Return value","title":"More Descriptive Analysis of Projection Pursuit Indices","text":"data_gen(\"polynomial\", ...) returns n × degree matrix. data_gen(<type>, ...) return tibble columns x, y, structure. noise_gen(...) returns tibble columns value (numeric) type (factor/character).","code":""},{"path":"/articles/more_descriptives.html","id":"finding-projection-pursuit-index-mean","dir":"Articles","previous_headings":"","what":"2) Finding Projection Pursuit Index Mean","title":"More Descriptive Analysis of Projection Pursuit Indices","text":"ppi_mean() simulates summarizes projection pursuit index (PPI) 2D variable pairs dataset. pair, repeats index evaluation n_sim times (sampling n_obs observations time) returns mean index per pair. tibble one row per variable pair: var_i, var_j; names variables forming pair. mean_index; mean index across n_sim simulations pair.","code":"res <- ppi_mean(   data,        # data frame with ≥ 2 numeric columns   index_fun,   # function taking n×2 matrix and returning a numeric value   n_sim = 100,   n_obs = 300 ) data <- as.data.frame(spinebil::data_gen(type = \"polynomial\", degree = 2)) res <- spinebil::ppi_mean(data, spinebil::scag_index(\"stringy\"), n_sim = 5) res #> # A tibble: 1 × 3 #>   var_i var_j mean_index #>   <chr> <chr>      <dbl> #> 1 1     2              1"},{"path":"/articles/more_descriptives.html","id":"function-usage-1","dir":"Articles","previous_headings":"","what":"Function usage","title":"More Descriptive Analysis of Projection Pursuit Indices","text":"","code":"res <- ppi_mean(   data,        # data frame with ≥ 2 numeric columns   index_fun,   # function taking n×2 matrix and returning a numeric value   n_sim = 100,   n_obs = 300 )"},{"path":"/articles/more_descriptives.html","id":"example-usage-1","dir":"Articles","previous_headings":"","what":"Example Usage","title":"More Descriptive Analysis of Projection Pursuit Indices","text":"","code":"data <- as.data.frame(spinebil::data_gen(type = \"polynomial\", degree = 2)) res <- spinebil::ppi_mean(data, spinebil::scag_index(\"stringy\"), n_sim = 5) res #> # A tibble: 1 × 3 #>   var_i var_j mean_index #>   <chr> <chr>      <dbl> #> 1 1     2              1"},{"path":"/articles/more_descriptives.html","id":"return-value-1","dir":"Articles","previous_headings":"","what":"Return value","title":"More Descriptive Analysis of Projection Pursuit Indices","text":"tibble one row per variable pair: var_i, var_j; names variables forming pair. mean_index; mean index across n_sim simulations pair.","code":""},{"path":"/articles/more_descriptives.html","id":"comparing-index-scale-on-structured-vs--noisy-data","dir":"Articles","previous_headings":"","what":"3) Comparing Index Scale on Structured vs. Noisy Data","title":"More Descriptive Analysis of Projection Pursuit Indices","text":"ppi_scale() runs simulations compare projection pursuit index (PPI) : Structured dataset (input), Pure Gaussian noise (sample size). every pair variables across many simulations, records index values cases can see scale separation index structure noise.","code":""},{"path":"/articles/more_descriptives.html","id":"function-usage-2","dir":"Articles","previous_headings":"","what":"Function Usage","title":"More Descriptive Analysis of Projection Pursuit Indices","text":"Inputs: data; data frame/tibble/matrix; (>= 2 numeric columns). index_fun; function: takes 2-column matrix returns numeric scalar (e.g., scag_index(\"stringy\")). n_sim; number simulations. n_obs; number observations. seed; optional seed reproducibility.","code":"ppi_scale(   data,           index_fun,    n_sim = 100,   n_obs = 500,   seed = NULL )"},{"path":"/articles/more_descriptives.html","id":"example-usage-2","dir":"Articles","previous_headings":"","what":"Example usage","title":"More Descriptive Analysis of Projection Pursuit Indices","text":"Let’s evaluate stringy index cassowaryr package see scale change pure noise structure. sigma = 0 structured sigma = 1 pure noise.","code":"res <- spinebil::ppi_scale(spinebil::data_gen(\"polynomial\", degree = 3), spinebil::scag_index(\"stringy\"), n_sim = 3)  head(res) #> # A tibble: 6 × 6 #>   simulation var_i var_j var_pair sigma index #>        <int> <chr> <chr> <chr>    <dbl> <dbl> #> 1          1 1     2     1-2          0 1     #> 2          1 1     2     1-2          1 0.732 #> 3          1 1     3     1-3          0 1     #> 4          1 1     3     1-3          1 0.783 #> 5          1 2     3     2-3          0 0.996 #> 6          1 2     3     2-3          1 0.719 res |>   dplyr::mutate(sigma = factor(sigma, levels = c(0, 1), labels = c(\"structured\", \"noise\"))) |>   ggplot2::ggplot(ggplot2::aes(x = sigma, y = index, fill = sigma)) +   ggplot2::geom_boxplot() +   ggplot2::facet_wrap(~var_pair) +   ggplot2::labs(     title = \"Index scale on structured vs noisy data\",     x = NULL, y = \"index\"   )"},{"path":"/articles/more_descriptives.html","id":"boxplots-structured-vs-noise-per-variable-pair","dir":"Articles","previous_headings":"","what":"Boxplots: structured vs noise per variable pair","title":"More Descriptive Analysis of Projection Pursuit Indices","text":"","code":"res |>   dplyr::mutate(sigma = factor(sigma, levels = c(0, 1), labels = c(\"structured\", \"noise\"))) |>   ggplot2::ggplot(ggplot2::aes(x = sigma, y = index, fill = sigma)) +   ggplot2::geom_boxplot() +   ggplot2::facet_wrap(~var_pair) +   ggplot2::labs(     title = \"Index scale on structured vs noisy data\",     x = NULL, y = \"index\"   )"},{"path":"/articles/more_descriptives.html","id":"return-value-2","dir":"Articles","previous_headings":"","what":"Return value","title":"More Descriptive Analysis of Projection Pursuit Indices","text":"ppi_scale() returns tibble columns: simulation: simulation index var_i, var_j: two variable names var_pair: \"var_i-var_j\" compact label. Structured value (sigma = 0); compute index actual pair. Noise value (sigma = 1); generate n_obs standard-normal x, y, scale mean 0 / sd 1, compute index. index: index value index_fun.","code":""},{"path":"/articles/more_descriptives.html","id":"estimating-a-noise-threshold-for-projection-pursuit-indices","dir":"Articles","previous_headings":"","what":"4) Estimating a Noise Threshold for Projection Pursuit Indices","title":"More Descriptive Analysis of Projection Pursuit Indices","text":"ppi_noise_threshold() estimates 95th percentile projection pursuit index (PPI) synthetic noise. gives null threshold: observed index real data exceeds value, may indicate non-random structure. function supports different noise types via noise_gen() (e.g., Gaussian, tt-distributed, Cauchy, microstructure) lets set number simulations sample size per simulation.","code":""},{"path":"/articles/more_descriptives.html","id":"function-usage-3","dir":"Articles","previous_headings":"","what":"Function usage","title":"More Descriptive Analysis of Projection Pursuit Indices","text":"Inputs : index_fun: function returns single numeric value. n_sim: number simulations. n_obs: sample size per simulation. noise_type / noise_level: passed noise_gen() control distribution scale. seed: reproducibility.","code":"ppi_noise_threshold(   index_fun,   n_sim = 100,   n_obs = 500,   noise_type  = \"gaussian\",   noise_level = 0.01,   seed = NULL )"},{"path":"/articles/more_descriptives.html","id":"example-usage-3","dir":"Articles","previous_headings":"","what":"Example Usage","title":"More Descriptive Analysis of Projection Pursuit Indices","text":"","code":"thr <- spinebil::ppi_noise_threshold(   index_fun   = scag_index(\"stringy\"),   noise_type  = \"cauchy\",   noise_level = 0.1,   n_sim       = 10,   n_obs       = 100 ) thr #> 95%  #>  NA"},{"path":"/articles/more_descriptives.html","id":"return-value-3","dir":"Articles","previous_headings":"","what":"Return value","title":"More Descriptive Analysis of Projection Pursuit Indices","text":"ppi_noise_threshold() returns single numeric: estimated 95th percentile index specified noise model.","code":""},{"path":"/articles/more_descriptives.html","id":"sample-size-effects-for-projection-pursuit-indices-under-gaussian-noise","dir":"Articles","previous_headings":"","what":"5) Sample-Size Effects for Projection Pursuit Indices under Gaussian Noise","title":"More Descriptive Analysis of Projection Pursuit Indices","text":"demonstrates use ppi_samplesize_effect() function study projection pursuit index (PPI) values behave increasing sample sizes purely noisy (Gaussian) data. size, computes specified index function samples records 95th percentile index values observed. helps estimate distributional behavior index pure noise, depending sample size. curves useful null reference: -curve values may indicate non-random structure.","code":""},{"path":"/articles/more_descriptives.html","id":"function-usage-4","dir":"Articles","previous_headings":"","what":"Function Usage","title":"More Descriptive Analysis of Projection Pursuit Indices","text":"index_fun: function accepts data one simulation returns single numeric index value. n_sim: number simulations per sample size (default 100). Internally, function evaluates grid sample sizes 30 2000 (denser small sizes), simulates n_sim draws , returns 95th percentile resulting index values.","code":"ppi_samplesize_effect(index_fun, n_sim = 100)"},{"path":"/articles/more_descriptives.html","id":"example-usage-4","dir":"Articles","previous_headings":"","what":"Example Usage","title":"More Descriptive Analysis of Projection Pursuit Indices","text":"Let’s evaluate stringy index cassowaryr package see values change noise sample size increases.","code":"result <- spinebil::ppi_samplesize_effect(spinebil::scag_index(\"stringy\"), n_sim = 4) head(result) #> # A tibble: 6 × 2 #>   sample_size percentile95 #>         <dbl>        <dbl> #> 1          30        0.816 #> 2          35        0.752 #> 3          40        0.832 #> 4          45        0.758 #> 5          50        0.815 #> 6          55        0.800 tail(result) #> # A tibble: 6 × 2 #>   sample_size percentile95 #>         <dbl>        <dbl> #> 1        1875        0.739 #> 2        1900        0.744 #> 3        1925        0.736 #> 4        1950        0.737 #> 5        1975        0.731 #> 6        2000        0.736 ggplot2::ggplot(result, ggplot2::aes(sample_size, percentile95)) +   ggplot2::geom_point(alpha = 0.7, size = 1) +   ggplot2::geom_smooth(se = FALSE, method = \"loess\", formula = y ~ x, span = 0.1) +   ggplot2::labs(     x = \"Sample size (n)\",     y = \"95th percentile of index\"   )"},{"path":"/articles/more_descriptives.html","id":"plot-the-95th-percentile","dir":"Articles","previous_headings":"","what":"Plot the 95th-percentile","title":"More Descriptive Analysis of Projection Pursuit Indices","text":"","code":"ggplot2::ggplot(result, ggplot2::aes(sample_size, percentile95)) +   ggplot2::geom_point(alpha = 0.7, size = 1) +   ggplot2::geom_smooth(se = FALSE, method = \"loess\", formula = y ~ x, span = 0.1) +   ggplot2::labs(     x = \"Sample size (n)\",     y = \"95th percentile of index\"   )"},{"path":"/articles/more_descriptives.html","id":"return-value-4","dir":"Articles","previous_headings":"","what":"Return value","title":"More Descriptive Analysis of Projection Pursuit Indices","text":"ppi_samplesize_effect() returns tibble: sample_size: sample size block simulations percentile95: empirical 95th percentile index across n_sim simulations size.","code":""},{"path":"/articles/ppiDiagnostics.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"spinebil: Core Diagnostics for Projection Pursuit Indices","text":"vignette presents compact workflow built around five functions: squintAngleEstimate(), profileRotation(), compareSmoothing(), timeSequence() getTrace().","code":""},{"path":"/articles/ppiDiagnostics.html","id":"packages","dir":"Articles","previous_headings":"","what":"Packages","title":"spinebil: Core Diagnostics for Projection Pursuit Indices","text":"","code":"library(spinebil) library(tourr) library(ggplot2) library(dplyr) library(tidyr)"},{"path":"/articles/ppiDiagnostics.html","id":"squintangleestimate","dir":"Articles","previous_headings":"","what":"1) squintAngleEstimate()","title":"spinebil: Core Diagnostics for Projection Pursuit Indices","text":"far away (projection space) pattern become visible chosen index? squintAngleEstimate(), produces distribution squint angles repeatedly walking random 2‑D planes toward assumed optimal plane (best view structure) recording first point along path user‑chosen index function exceeds visibility cutoff. Interpretation: Larger squint angles ⇒ easier see (index crosses cutoff still far optimal plane). Smaller squint angles ⇒ harder see (index crosses close optimal plane).","code":""},{"path":"/articles/ppiDiagnostics.html","id":"function-usage","dir":"Articles","previous_headings":"","what":"Function usage","title":"spinebil: Core Diagnostics for Projection Pursuit Indices","text":"","code":"squintAngleEstimate(   data,            # numeric matrix/data frame (n x p)   indexF,          # function: (n x 2) -> numeric scalar   cutoff,          # numeric threshold for 'visible'   structurePlane,  # 2-D basis (p x 2) representing the optimal view   n = 100,         # number of random starts   stepSize = 0.01  # interpolation step along the tour path )"},{"path":"/articles/ppiDiagnostics.html","id":"example-usage","dir":"Articles","previous_headings":"","what":"Example Usage","title":"spinebil: Core Diagnostics for Projection Pursuit Indices","text":"","code":"library(spinebil) data <- spiralData(4, 50) indexF <- scagIndex(\"stringy\") cutoff <- 0.7 structurePlane <- basisMatrix(3,4,4) squintAngleEstimate(data, indexF, cutoff, structurePlane, n=10) [1] 1.247627 1.440900 1.278476 1.364699 1.311972 1.235694 1.508794 1.251345  [9] 1.476975 1.561042"},{"path":"/articles/ppiDiagnostics.html","id":"inputs","dir":"Articles","previous_headings":"","what":"Inputs","title":"spinebil: Core Diagnostics for Projection Pursuit Indices","text":"Choose index matches pattern care . scagnostics-style indices, example: Set data‑driven results comparable across datasets indices. Preferred: 95th–99th percentile index computed random projections (null specific structure targeted). can use indexNoiseThreshold() estimate cutoff automatically. know two variables define structure, construct basis directly. Otherwise, run guided tour maximize index use best basis returns. n = 100 typically yields stable distribution summaries plots. stepSize = 0.01 good accuracy/speed trade‑. threshold crossing looks coarse (index jumps cutoff), try 0.005. runtime issue, use something larger (e.g., 0.02).","code":"indexF <- scagIndex(\"stringy\")   # sine-wave/spiral-like # indexF <- scagIndex(\"skinny\")  # elongated patterns"},{"path":"/articles/ppiDiagnostics.html","id":"indexf-what-kind-of-structure","dir":"Articles","previous_headings":"","what":"indexF (what kind of structure?)","title":"spinebil: Core Diagnostics for Projection Pursuit Indices","text":"Choose index matches pattern care . scagnostics-style indices, example:","code":"indexF <- scagIndex(\"stringy\")   # sine-wave/spiral-like # indexF <- scagIndex(\"skinny\")  # elongated patterns"},{"path":"/articles/ppiDiagnostics.html","id":"cutoff-when-do-we-call-it-visible","dir":"Articles","previous_headings":"","what":"cutoff (when do we call it visible?)","title":"spinebil: Core Diagnostics for Projection Pursuit Indices","text":"Set data‑driven results comparable across datasets indices. Preferred: 95th–99th percentile index computed random projections (null specific structure targeted). can use indexNoiseThreshold() estimate cutoff automatically.","code":""},{"path":"/articles/ppiDiagnostics.html","id":"structureplane-where-is-the-best-view","dir":"Articles","previous_headings":"","what":"structurePlane (where is the best view?)","title":"spinebil: Core Diagnostics for Projection Pursuit Indices","text":"know two variables define structure, construct basis directly. Otherwise, run guided tour maximize index use best basis returns.","code":""},{"path":"/articles/ppiDiagnostics.html","id":"n-and-stepsize","dir":"Articles","previous_headings":"","what":"n and stepSize","title":"spinebil: Core Diagnostics for Projection Pursuit Indices","text":"n = 100 typically yields stable distribution summaries plots. stepSize = 0.01 good accuracy/speed trade‑. threshold crossing looks coarse (index jumps cutoff), try 0.005. runtime issue, use something larger (e.g., 0.02).","code":""},{"path":"/articles/ppiDiagnostics.html","id":"return-value","dir":"Articles","previous_headings":"","what":"Return value","title":"spinebil: Core Diagnostics for Projection Pursuit Indices","text":"squintAngleEstimate() returns numeric vector length n containing squint-angle estimates specified index cutoff.","code":""},{"path":"/articles/ppiDiagnostics.html","id":"profilerotation","dir":"Articles","previous_headings":"","what":"2) profileRotation()","title":"spinebil: Core Diagnostics for Projection Pursuit Indices","text":"index value stay 2‑D data rotated? profileRotation() tests rotation invariance one 2-D projection indices. Interpretation Flat profile → rotation invariant. Oscillating profile → orientation dependence. d: numeric matrix 2 columns; 2-D data rotated. indexList: list functions, taking (n×2)(n \\times 2) numeric matrix returning single numeric index value. Examples: list(tourr::holes(), scagIndex(\"stringy\"), mineIndexE(\"MIC\")). indexLabels: character vector labels (one per index indexList) used column names result. n (default = 200): integer number rotation steps.  Perfect circle (constant radius) → rotation invariant. Deformed/flower-like shape → orientation dependence. numeric matrix n + 1 rows length(indexLabels) + 1 columns: One column per index (named indexLabels) containing index values angle. additional column alpha giving corresponding angles radians.","code":"profileRotation(   d,            # 2-column numeric matrix (the data to rotate)   indexList,    # list of functions: (n x 2) -> numeric   indexLabels,  # character labels for columns   n = 200       # number of rotation steps across [0, 2*pi] ) d <- as.matrix(sinData(2, 30)) New names: • `` -> `...1` • `` -> `...2` indexList <- list(tourr::holes(), scagIndex(\"stringy\"), mineIndexE(\"MIC\")) indexLabels <- c(\"holes\", \"stringy\", \"mic\") pRot <- profileRotation(d, indexList, indexLabels, n = 50) plotRotation(pRot)"},{"path":"/articles/ppiDiagnostics.html","id":"function-usage-1","dir":"Articles","previous_headings":"","what":"Function Usage","title":"spinebil: Core Diagnostics for Projection Pursuit Indices","text":"","code":"profileRotation(   d,            # 2-column numeric matrix (the data to rotate)   indexList,    # list of functions: (n x 2) -> numeric   indexLabels,  # character labels for columns   n = 200       # number of rotation steps across [0, 2*pi] )"},{"path":"/articles/ppiDiagnostics.html","id":"inputs-1","dir":"Articles","previous_headings":"","what":"Inputs","title":"spinebil: Core Diagnostics for Projection Pursuit Indices","text":"d: numeric matrix 2 columns; 2-D data rotated. indexList: list functions, taking (n×2)(n \\times 2) numeric matrix returning single numeric index value. Examples: list(tourr::holes(), scagIndex(\"stringy\"), mineIndexE(\"MIC\")). indexLabels: character vector labels (one per index indexList) used column names result. n (default = 200): integer number rotation steps.","code":""},{"path":"/articles/ppiDiagnostics.html","id":"example-usage-1","dir":"Articles","previous_headings":"","what":"Example Usage","title":"spinebil: Core Diagnostics for Projection Pursuit Indices","text":"","code":"d <- as.matrix(sinData(2, 30)) New names: • `` -> `...1` • `` -> `...2` indexList <- list(tourr::holes(), scagIndex(\"stringy\"), mineIndexE(\"MIC\")) indexLabels <- c(\"holes\", \"stringy\", \"mic\") pRot <- profileRotation(d, indexList, indexLabels, n = 50) plotRotation(pRot)"},{"path":"/articles/ppiDiagnostics.html","id":"interpretation","dir":"Articles","previous_headings":"","what":"Interpretation","title":"spinebil: Core Diagnostics for Projection Pursuit Indices","text":"Perfect circle (constant radius) → rotation invariant. Deformed/flower-like shape → orientation dependence.","code":""},{"path":"/articles/ppiDiagnostics.html","id":"return-value-1","dir":"Articles","previous_headings":"","what":"Return value","title":"spinebil: Core Diagnostics for Projection Pursuit Indices","text":"numeric matrix n + 1 rows length(indexLabels) + 1 columns: One column per index (named indexLabels) containing index values angle. additional column alpha giving corresponding angles radians.","code":""},{"path":"/articles/ppiDiagnostics.html","id":"comparesmoothing","dir":"Articles","previous_headings":"","what":"3) compareSmoothing()","title":"spinebil: Core Diagnostics for Projection Pursuit Indices","text":"Projection–pursuit indices evaluated along tour path can spiky due small numerical changes projection point-level noise. compareSmoothing() provides principled way smooth traces averaging index local perturbations, compare different smoothing strategies side--side. supports two kinds perturbations: jitterAngle: randomly jitter projection plane small angle alpha via geodesic moves, recompute index. jitterPoints: randomly jitter projected points small amount (using base::jitter()), recompute index. noSmoothing: original index perturbation. Averaging across multiple perturbations reduces high-frequency noise reveals underlying trend index along tour. d, numeric data matrix p columns. projected d %*% basis basis tPath. tPath, list (p × 2) projection bases. Typically built tour history using tourr::save_history() tourr::interpolate(). idx, index function accepting two-column matrix returning single numeric value (e.g., scagIndex(\"stringy\")). alphaV, numeric vector jitter magnitudes compare. n, number evaluations entering mean value calculation (larger n → smoother, slower).  noSmoothing (red, solid): raw index trace along tour. Spiky traces indicate high sensitivity tiny projection changes. jitterAngle (black, dashed): averaging nearby projection angles. Smooths high‑frequency variability caused small plane movements; preserves structure amplitude better index robust minor orientation shifts. jitterPoints (black, dotted): averaging point noise. Strong smoothing index sensitive local point perturbations. tibble columns: indexMean, mean index value frame (includes original, unjittered value). t, integer frame index along tour path. method, one \"jitterAngle\", \"jitterPoints\", \"noSmoothing\". alpha, jitter magnitude used row.","code":"compareSmoothing(   d,         # data matrix (n x p)   tPath,     # interpolated tour path: list of projection bases (p x 2)   idx,       # index function   alphaV = c(0.01, 0.05, 0.1),  jitter amounts to compare (for jittering angle or points)   n = 10     # number of evaluations entering mean value calculation ) d <- spiralData(3, 30) tPath <- tourr::save_history(d, max_bases=2) tPath <- as.list(tourr::interpolate(tPath, 0.3)) idx <- scagIndex(\"stringy\") compS <- compareSmoothing(d, tPath, idx, alphaV = c(0.01, 0.05), n=2) plotSmoothingComparison(compS, lPos = \"bottom\")"},{"path":"/articles/ppiDiagnostics.html","id":"function-usage-2","dir":"Articles","previous_headings":"","what":"Function Usage","title":"spinebil: Core Diagnostics for Projection Pursuit Indices","text":"","code":"compareSmoothing(   d,         # data matrix (n x p)   tPath,     # interpolated tour path: list of projection bases (p x 2)   idx,       # index function   alphaV = c(0.01, 0.05, 0.1),  jitter amounts to compare (for jittering angle or points)   n = 10     # number of evaluations entering mean value calculation )"},{"path":"/articles/ppiDiagnostics.html","id":"inputs-2","dir":"Articles","previous_headings":"","what":"Inputs","title":"spinebil: Core Diagnostics for Projection Pursuit Indices","text":"d, numeric data matrix p columns. projected d %*% basis basis tPath. tPath, list (p × 2) projection bases. Typically built tour history using tourr::save_history() tourr::interpolate(). idx, index function accepting two-column matrix returning single numeric value (e.g., scagIndex(\"stringy\")). alphaV, numeric vector jitter magnitudes compare. n, number evaluations entering mean value calculation (larger n → smoother, slower).","code":""},{"path":"/articles/ppiDiagnostics.html","id":"example-usage-2","dir":"Articles","previous_headings":"","what":"Example Usage","title":"spinebil: Core Diagnostics for Projection Pursuit Indices","text":"","code":"d <- spiralData(3, 30) tPath <- tourr::save_history(d, max_bases=2) tPath <- as.list(tourr::interpolate(tPath, 0.3)) idx <- scagIndex(\"stringy\") compS <- compareSmoothing(d, tPath, idx, alphaV = c(0.01, 0.05), n=2) plotSmoothingComparison(compS, lPos = \"bottom\")"},{"path":"/articles/ppiDiagnostics.html","id":"interpretation-1","dir":"Articles","previous_headings":"","what":"Interpretation","title":"spinebil: Core Diagnostics for Projection Pursuit Indices","text":"noSmoothing (red, solid): raw index trace along tour. Spiky traces indicate high sensitivity tiny projection changes. jitterAngle (black, dashed): averaging nearby projection angles. Smooths high‑frequency variability caused small plane movements; preserves structure amplitude better index robust minor orientation shifts. jitterPoints (black, dotted): averaging point noise. Strong smoothing index sensitive local point perturbations.","code":""},{"path":"/articles/ppiDiagnostics.html","id":"return-value-2","dir":"Articles","previous_headings":"","what":"Return value","title":"spinebil: Core Diagnostics for Projection Pursuit Indices","text":"tibble columns: indexMean, mean index value frame (includes original, unjittered value). t, integer frame index along tour path. method, one \"jitterAngle\", \"jitterPoints\", \"noSmoothing\". alpha, jitter magnitude used row.","code":""},{"path":"/articles/ppiDiagnostics.html","id":"timesequence","dir":"Articles","previous_headings":"","what":"4) timeSequence()","title":"spinebil: Core Diagnostics for Projection Pursuit Indices","text":"cost evaluating projection pursuit index can vary data distribution projection. timeSequence() times index sequence projection bases returns simple table can plot summarise. d: numeric matrix size n×pn \\times p. t: list (p × 2) projection bases (e.g., tourr::basis_random() interpolated tour history). idx: index function mapping two-column matrix single numeric value (e.g., scagIndex(\"stringy\")). pmax: integer limit; evaluation stops pmax projections even t longer. data frame two columns: t: elapsed time seconds index evaluation projection. : sequence index (1, 2, …) projection t.","code":"timeSequence(   d,      # numeric data matrix (n x p)   t,      # list of projection matrices (each p x 2); e.g., an interpolated tour path   idx,    # index function: (n x 2) -> numeric   pmax    # maximum number of projections to evaluate (cut t if longer than pmax) ) d <- spiralData(4, 500) t <- purrr::map(1:10, ~ tourr::basis_random(4)) idx <- scagIndex(\"stringy\") timeSequence(d, t, idx, 10) t  i 1  0.042  1 2  0.041  2 3  0.040  3 4  0.041  4 5  0.040  5 6  0.042  6 7  0.044  7 8  0.040  8 9  0.042  9 10 0.048 10"},{"path":"/articles/ppiDiagnostics.html","id":"function-usage-3","dir":"Articles","previous_headings":"","what":"Function Usage","title":"spinebil: Core Diagnostics for Projection Pursuit Indices","text":"","code":"timeSequence(   d,      # numeric data matrix (n x p)   t,      # list of projection matrices (each p x 2); e.g., an interpolated tour path   idx,    # index function: (n x 2) -> numeric   pmax    # maximum number of projections to evaluate (cut t if longer than pmax) )"},{"path":"/articles/ppiDiagnostics.html","id":"inputs-3","dir":"Articles","previous_headings":"","what":"Inputs","title":"spinebil: Core Diagnostics for Projection Pursuit Indices","text":"d: numeric matrix size n×pn \\times p. t: list (p × 2) projection bases (e.g., tourr::basis_random() interpolated tour history). idx: index function mapping two-column matrix single numeric value (e.g., scagIndex(\"stringy\")). pmax: integer limit; evaluation stops pmax projections even t longer.","code":""},{"path":"/articles/ppiDiagnostics.html","id":"example-usage-3","dir":"Articles","previous_headings":"","what":"Example Usage","title":"spinebil: Core Diagnostics for Projection Pursuit Indices","text":"","code":"d <- spiralData(4, 500) t <- purrr::map(1:10, ~ tourr::basis_random(4)) idx <- scagIndex(\"stringy\") timeSequence(d, t, idx, 10) t  i 1  0.042  1 2  0.041  2 3  0.040  3 4  0.041  4 5  0.040  5 6  0.042  6 7  0.044  7 8  0.040  8 9  0.042  9 10 0.048 10"},{"path":"/articles/ppiDiagnostics.html","id":"return-value-3","dir":"Articles","previous_headings":"","what":"Return value","title":"spinebil: Core Diagnostics for Projection Pursuit Indices","text":"data frame two columns: t: elapsed time seconds index evaluation projection. : sequence index (1, 2, …) projection t.","code":""},{"path":"/articles/ppiDiagnostics.html","id":"gettrace","dir":"Articles","previous_headings":"","what":"5) getTrace()","title":"spinebil: Core Diagnostics for Projection Pursuit Indices","text":"getTrace() evaluates one projection pursuit indices along interpolated, planned tour path returns values frame. Plotting traces reveals whether index varies smoothly small changes projection (desirable), exhibits spikes (potentially unstable, overly sensitive, ‑smoothed). smooth trace indicates small rotations view produce small changes index,important property guided tours optimisation. combination plotTrace(), can quickly diagnose index behaviour across path connecting user‑specified views.","code":""},{"path":"/articles/ppiDiagnostics.html","id":"function-usage-4","dir":"Articles","previous_headings":"","what":"Function Usage","title":"spinebil: Core Diagnostics for Projection Pursuit Indices","text":"","code":"getTrace(   d,           # data: matrix/data frame (n x p)   m,           # list of projection matrices for the planned tour   indexList,   # list of index functions to calculate for each entry -> numeric   indexLabels  # character vector of labels for the indices )"},{"path":"/articles/ppiDiagnostics.html","id":"inputs-4","dir":"Articles","previous_headings":"","what":"Inputs","title":"spinebil: Core Diagnostics for Projection Pursuit Indices","text":"d; numeric data p columns. m; list (p × 2) projection matrices planned tour. indexList; list functions take two‑column matrix return numeric scalar (e.g., tourr::holes(), tourr::cmass(), scagIndex(\"stringy\")). indexLabels; character vector length order indexList; used column names output.","code":""},{"path":"/articles/ppiDiagnostics.html","id":"example-usage-4","dir":"Articles","previous_headings":"","what":"Example Usage","title":"spinebil: Core Diagnostics for Projection Pursuit Indices","text":"","code":"d <- spiralData(4, 100) m <- list(basisMatrix(1,2,4), basisMatrix(3,4,4)) indexList <- list(tourr::holes(), tourr::cmass()) indexLabels <- c(\"holes\", \"cmass\") trace <- getTrace(d, m, indexList, indexLabels) plotTrace(trace) plotTrace(trace, rescY = FALSE)"},{"path":"/articles/ppiDiagnostics.html","id":"return-value-4","dir":"Articles","previous_headings":"","what":"Return value","title":"spinebil: Core Diagnostics for Projection Pursuit Indices","text":"numeric matrix length(indexLabels) + 1 columns many rows interpolation frames. Columns index values (named indexLabels) t (frame index).","code":""},{"path":"/articles/ppi_diagnostics.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Core Diagnostics for Projection Pursuit Indices","text":"vignette introduce three example datasets; spiral, sine, pipe dataset evaluate five key characteristics projection pursuit indices (PPIs): smoothness, squintability, flexibility, rotation invariance speed. generate datasets first, walk one section per characteristic functions provided spinebil.","code":""},{"path":"/articles/ppi_diagnostics.html","id":"data-generators","dir":"Articles","previous_headings":"","what":"Data Generators","title":"Core Diagnostics for Projection Pursuit Indices","text":"pipe_data(n, p, t); pipe (circular ring) structure. sin_data(n, p, f); sine relationship. spiral_data(n, p); archimedean spiral.  Now employ patterns evaluate key characteristics PPIs.","code":"n <- 500 p <- 4 lst <- list(   Pipe   = spinebil::pipe_data(n, p),   Sine   = spinebil::sin_data(n, p, 1),   Spiral = spinebil::spiral_data(n, p) )  df_all <- do.call(rbind, lapply(names(lst), function(lbl) {   d <- lst[[lbl]]   data.frame(x = d[[p - 1]], y = d[[p]], structure = lbl) }))  ggplot2::ggplot(df_all, ggplot2::aes(x, y)) +   ggplot2::geom_point(alpha = 0.6, size = 0.6) +   ggplot2::facet_wrap(~ structure, nrow = 1) +   ggplot2::coord_equal() +   ggplot2::theme(     axis.text  = ggplot2::element_blank(),     axis.ticks = ggplot2::element_blank(),     axis.title = ggplot2::element_blank()   )"},{"path":"/articles/ppi_diagnostics.html","id":"compare_smoothing","dir":"Articles","previous_headings":"","what":"1) compare_smoothing()","title":"Core Diagnostics for Projection Pursuit Indices","text":"Projection pursuit indices evaluated along tour path can spiky due small numerical changes projection point-level noise. compare_smoothing() provides principled way smooth traces averaging index local perturbations, compare different smoothing strategies side--side. supports two kinds perturbations: jitter_angle: randomly jitter projection plane small angle alpha via geodesic moves, recompute index. jitter_points: randomly jitter projected points small amount (using base::jitter()), recompute index. no_smoothing: original index perturbation. Averaging across multiple perturbations reduces high-frequency noise reveals underlying trend index along tour. d, numeric data matrix p columns. projected d %*% basis basis tPath. tPath, list (p × 2) projection bases. Typically built tour history using tourr::save_history() tourr::interpolate(). idx, index function accepting two-column matrix returning single numeric value (e.g., scag_index(\"stringy\")). alphaV, numeric vector jitter magnitudes compare. n, number evaluations entering mean value calculation (larger n → smoother, slower).  no_smoothing (red, solid): raw index trace along tour. Spiky traces indicate high sensitivity tiny projection changes. jitter_angle (black, dashed): averaging nearby projection angles. Smooths high‑frequency variability caused small plane movements; preserves structure amplitude better index robust minor orientation shifts. jitter_points (black, dotted): averaging point noise. Strong smoothing index sensitive local point perturbations. tibble columns: index_mean, mean index value frame (includes original, unjittered value). t, integer frame index along tour path. method, one \"jitter_angle\", \"jitter_points\", \"no_smoothing\". alpha, jitter magnitude used row.","code":"compare_smoothing(   d,         # data matrix (n x p)   tPath,     # interpolated tour path: list of projection bases (p x 2)   idx,       # index function   alphaV = c(0.01, 0.05, 0.1),  jitter amounts to compare (for jittering angle or points)   n = 10     # number of evaluations entering mean value calculation ) d <- as.matrix(spinebil::spiral_data(30,4)) tPath <- tourr::save_history(d, max_bases=2) tPath <- as.list(tourr::interpolate(tPath, 0.3)) idx <- spinebil::scag_index(\"stringy\") compS <- spinebil::compare_smoothing(d, tPath, idx, alphaV = c(0.01, 0.05), n=2) spinebil::plot_smoothing_comparison(compS, lPos = \"bottom\")"},{"path":"/articles/ppi_diagnostics.html","id":"function-usage","dir":"Articles","previous_headings":"","what":"Function Usage","title":"Core Diagnostics for Projection Pursuit Indices","text":"","code":"compare_smoothing(   d,         # data matrix (n x p)   tPath,     # interpolated tour path: list of projection bases (p x 2)   idx,       # index function   alphaV = c(0.01, 0.05, 0.1),  jitter amounts to compare (for jittering angle or points)   n = 10     # number of evaluations entering mean value calculation )"},{"path":"/articles/ppi_diagnostics.html","id":"inputs","dir":"Articles","previous_headings":"","what":"Inputs","title":"Core Diagnostics for Projection Pursuit Indices","text":"d, numeric data matrix p columns. projected d %*% basis basis tPath. tPath, list (p × 2) projection bases. Typically built tour history using tourr::save_history() tourr::interpolate(). idx, index function accepting two-column matrix returning single numeric value (e.g., scag_index(\"stringy\")). alphaV, numeric vector jitter magnitudes compare. n, number evaluations entering mean value calculation (larger n → smoother, slower).","code":""},{"path":"/articles/ppi_diagnostics.html","id":"example-usage","dir":"Articles","previous_headings":"","what":"Example Usage","title":"Core Diagnostics for Projection Pursuit Indices","text":"","code":"d <- as.matrix(spinebil::spiral_data(30,4)) tPath <- tourr::save_history(d, max_bases=2) tPath <- as.list(tourr::interpolate(tPath, 0.3)) idx <- spinebil::scag_index(\"stringy\") compS <- spinebil::compare_smoothing(d, tPath, idx, alphaV = c(0.01, 0.05), n=2) spinebil::plot_smoothing_comparison(compS, lPos = \"bottom\")"},{"path":"/articles/ppi_diagnostics.html","id":"interpretation","dir":"Articles","previous_headings":"","what":"Interpretation","title":"Core Diagnostics for Projection Pursuit Indices","text":"no_smoothing (red, solid): raw index trace along tour. Spiky traces indicate high sensitivity tiny projection changes. jitter_angle (black, dashed): averaging nearby projection angles. Smooths high‑frequency variability caused small plane movements; preserves structure amplitude better index robust minor orientation shifts. jitter_points (black, dotted): averaging point noise. Strong smoothing index sensitive local point perturbations.","code":""},{"path":"/articles/ppi_diagnostics.html","id":"return-value","dir":"Articles","previous_headings":"","what":"Return value","title":"Core Diagnostics for Projection Pursuit Indices","text":"tibble columns: index_mean, mean index value frame (includes original, unjittered value). t, integer frame index along tour path. method, one \"jitter_angle\", \"jitter_points\", \"no_smoothing\". alpha, jitter magnitude used row.","code":""},{"path":"/articles/ppi_diagnostics.html","id":"squint_angle_estimate","dir":"Articles","previous_headings":"","what":"2) squint_angle_estimate()","title":"Core Diagnostics for Projection Pursuit Indices","text":"far away (projection space) pattern become visible chosen index? squint_angle_estimate(), produces distribution squint angles repeatedly walking random 2‑D planes toward assumed optimal plane (best view structure) recording first point along path user‑chosen index function exceeds visibility cutoff. Interpretation: Larger squint angles ⇒ easier see (index crosses cutoff still far optimal plane). Smaller squint angles ⇒ harder see (index crosses close optimal plane).","code":""},{"path":"/articles/ppi_diagnostics.html","id":"function-usage-1","dir":"Articles","previous_headings":"","what":"Function usage","title":"Core Diagnostics for Projection Pursuit Indices","text":"","code":"squint_angle_estimate(   data,            # numeric matrix/data frame (n x p)   indexF,          # function: (n x 2) -> numeric scalar   cutoff,          # numeric threshold for 'visible'   structure_plane,  # 2-D basis (p x 2) representing the optimal view   n = 100,         # number of random starts   step_size = 0.01  # interpolation step along the tour path )"},{"path":"/articles/ppi_diagnostics.html","id":"example-usage-1","dir":"Articles","previous_headings":"","what":"Example Usage","title":"Core Diagnostics for Projection Pursuit Indices","text":"","code":"data <- as.matrix(spinebil::spiral_data(50, 4)) indexF <- spinebil::scag_index(\"stringy\") cutoff <- 0.7 structure_plane <- spinebil::basis_matrix(3,4,4) spinebil::squint_angle_estimate(data, indexF, cutoff, structure_plane, n=10) #>  [1] 1.278895 1.517389 1.415894 1.649694 1.390649 1.146645 1.005732 1.497377 #>  [9] 1.066281 1.755652"},{"path":"/articles/ppi_diagnostics.html","id":"inputs-1","dir":"Articles","previous_headings":"","what":"Inputs","title":"Core Diagnostics for Projection Pursuit Indices","text":"Choose index matches pattern care . scagnostics-style indices, example: Set data‑driven results comparable across datasets indices. Preferred: 95th–99th percentile index computed random projections (null specific structure targeted). can use index_noise_threshold() estimate cutoff automatically. know two variables define structure, construct basis directly. Otherwise, run guided tour maximize index use best basis returns. n = 100 typically yields stable distribution summaries plots. step_size = 0.01 good accuracy/speed trade‑. threshold crossing looks coarse (index jumps cutoff), try 0.005. runtime issue, use something larger (e.g., 0.02).","code":"indexF <- scag_index(\"stringy\")   # sine-wave/spiral-like indexF <- scag_index(\"skinny\")  # elongated patterns"},{"path":"/articles/ppi_diagnostics.html","id":"indexf-what-kind-of-structure","dir":"Articles","previous_headings":"","what":"indexF (what kind of structure?)","title":"Core Diagnostics for Projection Pursuit Indices","text":"Choose index matches pattern care . scagnostics-style indices, example:","code":"indexF <- scag_index(\"stringy\")   # sine-wave/spiral-like indexF <- scag_index(\"skinny\")  # elongated patterns"},{"path":"/articles/ppi_diagnostics.html","id":"cutoff-when-do-we-call-it-visible","dir":"Articles","previous_headings":"","what":"cutoff (when do we call it visible?)","title":"Core Diagnostics for Projection Pursuit Indices","text":"Set data‑driven results comparable across datasets indices. Preferred: 95th–99th percentile index computed random projections (null specific structure targeted). can use index_noise_threshold() estimate cutoff automatically.","code":""},{"path":"/articles/ppi_diagnostics.html","id":"structure_plane-where-is-the-best-view","dir":"Articles","previous_headings":"","what":"structure_plane (where is the best view?)","title":"Core Diagnostics for Projection Pursuit Indices","text":"know two variables define structure, construct basis directly. Otherwise, run guided tour maximize index use best basis returns.","code":""},{"path":"/articles/ppi_diagnostics.html","id":"n-and-step_size","dir":"Articles","previous_headings":"","what":"n and step_size","title":"Core Diagnostics for Projection Pursuit Indices","text":"n = 100 typically yields stable distribution summaries plots. step_size = 0.01 good accuracy/speed trade‑. threshold crossing looks coarse (index jumps cutoff), try 0.005. runtime issue, use something larger (e.g., 0.02).","code":""},{"path":"/articles/ppi_diagnostics.html","id":"return-value-1","dir":"Articles","previous_headings":"","what":"Return value","title":"Core Diagnostics for Projection Pursuit Indices","text":"squint_angle_estimate() returns numeric vector length n containing squint-angle estimates specified index cutoff.","code":""},{"path":"/articles/ppi_diagnostics.html","id":"get_trace","dir":"Articles","previous_headings":"","what":"3) get_trace()","title":"Core Diagnostics for Projection Pursuit Indices","text":"get_trace() evaluates one projection pursuit indices along interpolated, planned tour path returns values frame. Plotting traces reveals whether index varies smoothly small changes projection (desirable), exhibits spikes (potentially unstable, overly sensitive, ‑smoothed). smooth trace indicates small rotations view produce small changes index,important property guided tours optimisation. combination plot_trace(), can quickly diagnose index behaviour across path connecting user‑specified views.","code":""},{"path":"/articles/ppi_diagnostics.html","id":"function-usage-2","dir":"Articles","previous_headings":"","what":"Function Usage","title":"Core Diagnostics for Projection Pursuit Indices","text":"","code":"get_trace(   d,           # data: matrix/data frame (n x p)   m,           # list of projection matrices for the planned tour   index_list,   # list of index functions to calculate for each entry -> numeric   index_labels  # character vector of labels for the indices )"},{"path":"/articles/ppi_diagnostics.html","id":"inputs-2","dir":"Articles","previous_headings":"","what":"Inputs","title":"Core Diagnostics for Projection Pursuit Indices","text":"d; numeric data p columns. m; list (p × 2) projection matrices planned tour. index_list; list functions take two‑column matrix return numeric scalar (e.g., tourr::holes(), tourr::cmass(), scag_index(\"stringy\")). index_labels; character vector length order index_list; used column names output.","code":""},{"path":"/articles/ppi_diagnostics.html","id":"example-usage-2","dir":"Articles","previous_headings":"","what":"Example Usage","title":"Core Diagnostics for Projection Pursuit Indices","text":"","code":"d <- as.matrix(spinebil::spiral_data(100, 4)) m <- list(spinebil::basis_matrix(1,2,4), spinebil::basis_matrix(3,4,4)) index_list <- list(tourr::holes(), tourr::norm_kol(100)) index_labels <- c(\"holes\", \"norm kol\") trace <- spinebil::get_trace(d, m, index_list, index_labels) spinebil::plot_trace(trace) spinebil::plot_trace(trace, rescY = FALSE)"},{"path":"/articles/ppi_diagnostics.html","id":"return-value-2","dir":"Articles","previous_headings":"","what":"Return value","title":"Core Diagnostics for Projection Pursuit Indices","text":"numeric matrix length(index_labels) + 1 columns many rows interpolation frames. Columns index values (named index_labels) t (frame index).","code":""},{"path":"/articles/ppi_diagnostics.html","id":"profile_rotation","dir":"Articles","previous_headings":"","what":"4) profile_rotation()","title":"Core Diagnostics for Projection Pursuit Indices","text":"index value stay 2‑D data rotated? profile_rotation() tests rotation invariance one 2-D projection indices. Interpretation Flat profile → rotation invariant. Oscillating profile → orientation dependence. d: numeric matrix 2 columns; 2-D data rotated. index_list: list functions, taking (n×2)(n \\times 2) numeric matrix returning single numeric index value. Examples: list(tourr::holes(), scag_index(\"stringy\"), mine_indexE(\"MIC\")). index_labels: character vector labels (one per index index_list) used column names result. n (default = 200): integer number rotation steps.  Perfect circle (constant radius) → rotation invariant. Deformed/flower-like shape → orientation dependence. numeric matrix n + 1 rows length(index_labels) + 1 columns: One column per index (named index_labels) containing index values angle. additional column alpha giving corresponding angles radians.","code":"profile_rotation(   d,            # 2-column numeric matrix (the data to rotate)   index_list,    # list of functions: (n x 2) -> numeric   index_labels,  # character labels for columns   n = 200       # number of rotation steps across [0, 2*pi] ) d <- as.matrix(spinebil::sin_data(30, 2)) index_list <- list(tourr::holes(), spinebil::scag_index(\"stringy\"), spinebil::mine_indexE(\"MIC\")) index_labels <- c(\"holes\", \"stringy\", \"mic\") pRot <- spinebil::profile_rotation(d, index_list, index_labels, n = 50) spinebil::plot_rotation(pRot)"},{"path":"/articles/ppi_diagnostics.html","id":"function-usage-3","dir":"Articles","previous_headings":"","what":"Function Usage","title":"Core Diagnostics for Projection Pursuit Indices","text":"","code":"profile_rotation(   d,            # 2-column numeric matrix (the data to rotate)   index_list,    # list of functions: (n x 2) -> numeric   index_labels,  # character labels for columns   n = 200       # number of rotation steps across [0, 2*pi] )"},{"path":"/articles/ppi_diagnostics.html","id":"inputs-3","dir":"Articles","previous_headings":"","what":"Inputs","title":"Core Diagnostics for Projection Pursuit Indices","text":"d: numeric matrix 2 columns; 2-D data rotated. index_list: list functions, taking (n×2)(n \\times 2) numeric matrix returning single numeric index value. Examples: list(tourr::holes(), scag_index(\"stringy\"), mine_indexE(\"MIC\")). index_labels: character vector labels (one per index index_list) used column names result. n (default = 200): integer number rotation steps.","code":""},{"path":"/articles/ppi_diagnostics.html","id":"example-usage-3","dir":"Articles","previous_headings":"","what":"Example Usage","title":"Core Diagnostics for Projection Pursuit Indices","text":"","code":"d <- as.matrix(spinebil::sin_data(30, 2)) index_list <- list(tourr::holes(), spinebil::scag_index(\"stringy\"), spinebil::mine_indexE(\"MIC\")) index_labels <- c(\"holes\", \"stringy\", \"mic\") pRot <- spinebil::profile_rotation(d, index_list, index_labels, n = 50) spinebil::plot_rotation(pRot)"},{"path":"/articles/ppi_diagnostics.html","id":"interpretation-1","dir":"Articles","previous_headings":"","what":"Interpretation","title":"Core Diagnostics for Projection Pursuit Indices","text":"Perfect circle (constant radius) → rotation invariant. Deformed/flower-like shape → orientation dependence.","code":""},{"path":"/articles/ppi_diagnostics.html","id":"return-value-3","dir":"Articles","previous_headings":"","what":"Return value","title":"Core Diagnostics for Projection Pursuit Indices","text":"numeric matrix n + 1 rows length(index_labels) + 1 columns: One column per index (named index_labels) containing index values angle. additional column alpha giving corresponding angles radians.","code":""},{"path":"/articles/ppi_diagnostics.html","id":"time_sequence","dir":"Articles","previous_headings":"","what":"5) time_sequence()","title":"Core Diagnostics for Projection Pursuit Indices","text":"cost evaluating projection pursuit index can vary data distribution projection. time_sequence() times index sequence projection bases returns simple table can plot summarise. d: numeric matrix size n×pn \\times p. t: list (p × 2) projection bases (e.g., tourr::basis_random() interpolated tour history). idx: index function mapping two-column matrix single numeric value (e.g., scag_index(\"stringy\")). pmax: integer limit; evaluation stops pmax projections even t longer. data frame two columns: t: elapsed time seconds index evaluation projection. : sequence index (1, 2, …) projection t.","code":"time_sequence(   d,      # numeric data matrix (n x p)   t,      # list of projection matrices (each p x 2); e.g., an interpolated tour path   idx,    # index function: (n x 2) -> numeric   pmax    # maximum number of projections to evaluate (cut t if longer than pmax) ) d <- as.matrix(spinebil::spiral_data(500, 4)) t <- purrr::map(1:10, ~ tourr::basis_random(4)) idx <- spinebil::scag_index(\"stringy\") spinebil::time_sequence(d, t, idx, 10) #>        t  i #> 1  0.035  1 #> 2  0.037  2 #> 3  0.034  3 #> 4  0.040  4 #> 5  0.039  5 #> 6  0.035  6 #> 7  0.038  7 #> 8  0.037  8 #> 9  0.039  9 #> 10 0.040 10"},{"path":"/articles/ppi_diagnostics.html","id":"function-usage-4","dir":"Articles","previous_headings":"","what":"Function Usage","title":"Core Diagnostics for Projection Pursuit Indices","text":"","code":"time_sequence(   d,      # numeric data matrix (n x p)   t,      # list of projection matrices (each p x 2); e.g., an interpolated tour path   idx,    # index function: (n x 2) -> numeric   pmax    # maximum number of projections to evaluate (cut t if longer than pmax) )"},{"path":"/articles/ppi_diagnostics.html","id":"inputs-4","dir":"Articles","previous_headings":"","what":"Inputs","title":"Core Diagnostics for Projection Pursuit Indices","text":"d: numeric matrix size n×pn \\times p. t: list (p × 2) projection bases (e.g., tourr::basis_random() interpolated tour history). idx: index function mapping two-column matrix single numeric value (e.g., scag_index(\"stringy\")). pmax: integer limit; evaluation stops pmax projections even t longer.","code":""},{"path":"/articles/ppi_diagnostics.html","id":"example-usage-4","dir":"Articles","previous_headings":"","what":"Example Usage","title":"Core Diagnostics for Projection Pursuit Indices","text":"","code":"d <- as.matrix(spinebil::spiral_data(500, 4)) t <- purrr::map(1:10, ~ tourr::basis_random(4)) idx <- spinebil::scag_index(\"stringy\") spinebil::time_sequence(d, t, idx, 10) #>        t  i #> 1  0.035  1 #> 2  0.037  2 #> 3  0.034  3 #> 4  0.040  4 #> 5  0.039  5 #> 6  0.035  6 #> 7  0.038  7 #> 8  0.037  8 #> 9  0.039  9 #> 10 0.040 10"},{"path":"/articles/ppi_diagnostics.html","id":"return-value-4","dir":"Articles","previous_headings":"","what":"Return value","title":"Core Diagnostics for Projection Pursuit Indices","text":"data frame two columns: t: elapsed time seconds index evaluation projection. : sequence index (1, 2, …) projection t.","code":""},{"path":"/articles/sampleSizeEffect.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Sample-Size Effects for Projection Pursuit Indexes under Gaussian Noise","text":"demonstrates use ppi_samplesize_effect() function study projection pursuit index (PPI) values behave increasing sample sizes purely noisy (Gaussian) data. Understanding index behaves null conditions critical : Calibrating thresholds statistical significance Identifying sensitivity sample size Comparing robustness across different index functions","code":""},{"path":"/articles/sampleSizeEffect.html","id":"what-the-function-does","dir":"Articles","previous_headings":"","what":"What the Function Does","title":"Sample-Size Effects for Projection Pursuit Indexes under Gaussian Noise","text":"function ppi_samplesize_effect() runs repeated simulations standard normal noise across range sample sizes. size, computes specified index function samples records 95th percentile index values observed. helps estimate distributional behavior index pure noise, depending sample size. curves useful null reference: -curve values may indicate non-random structure.","code":"library(ggplot2) library(spinebil) library(cassowaryr)"},{"path":"/articles/sampleSizeEffect.html","id":"function-usage","dir":"Articles","previous_headings":"","what":"Function usage","title":"Sample-Size Effects for Projection Pursuit Indexes under Gaussian Noise","text":"index_fun: function accepts data one simulation returns single numeric index value. n_sim: number simulations per sample size (default 100). Internally, function evaluates grid sample sizes 30 2000 (denser small sizes), simulates n_sim draws , returns 95th percentile resulting index values.","code":"ppi_samplesize_effect(index_fun, n_sim = 100)"},{"path":"/articles/sampleSizeEffect.html","id":"example-usage","dir":"Articles","previous_headings":"","what":"Example Usage","title":"Sample-Size Effects for Projection Pursuit Indexes under Gaussian Noise","text":"Let’s evaluate stringy index cassowaryr package see values change noise sample size increases.","code":"result <- ppi_samplesize_effect(scagIndex(\"stringy\"), n_sim = 4) head(result) #> # A tibble: 6 × 2 #>   SampleSize Percentile95 #>        <dbl>        <dbl> #> 1         30        0.762 #> 2         35        0.768 #> 3         40        0.788 #> 4         45        0.793 #> 5         50        0.755 #> 6         55        0.802 tail(result) #> # A tibble: 6 × 2 #>   SampleSize Percentile95 #>        <dbl>        <dbl> #> 1       1875        0.744 #> 2       1900        0.742 #> 3       1925        0.740 #> 4       1950        0.734 #> 5       1975        0.735 #> 6       2000        0.744"},{"path":"/articles/sampleSizeEffect.html","id":"plot-the-95th-percentile","dir":"Articles","previous_headings":"","what":"Plot the 95th-percentile","title":"Sample-Size Effects for Projection Pursuit Indexes under Gaussian Noise","text":"","code":"ggplot(result, aes(SampleSize, Percentile95)) +   geom_point(alpha = 0.7, size = 1) +   geom_smooth(se = FALSE, method = \"loess\", formula = y ~ x, span = 0.1) +   labs(     x = \"Sample size (n)\",     y = \"95th percentile of index\"   )"},{"path":"/articles/sampleSizeEffect.html","id":"return-value","dir":"Articles","previous_headings":"","what":"Return value","title":"Sample-Size Effects for Projection Pursuit Indexes under Gaussian Noise","text":"ppi_samplesize_effect() returns tibble: SampleSize: sample size block simulations Percentile95: empirical 95th percentile index across n_sim simulations size.","code":""},{"path":"/articles/spinebil.html","id":"about","dir":"Articles","previous_headings":"","what":"About","title":"An introduction to the spinebil package","text":"spinebil package provides tools explore evaluate behavior Projection Pursuit Index (PPI) functions using tour methods, specifically focusing interpolated paths line graphs. offers structured approach assessing different PPI functions behave applied data known structure noise, tracing values along controlled transitions projection planes. Projection pursuit powerful technique multivariate statistics seeks “interesting” low-dimensional projections high-dimensional data. projections identified optimizing index function designed highlight structure clustering, outliers, non-Gaussianity. methods implemented spinebil described detail paper, package builds prior work tourr package.","code":""},{"path":"/articles/spinebil.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"An introduction to the spinebil package","text":"package can installed CRAN using: can install development version GitHub :","code":"install.packages(\"spinebil\") # install.packages(\"devtools\") devtools::install_github(\"uschiLaa/spinebil\")"},{"path":"/articles/spinebil.html","id":"purpose","dir":"Articles","previous_headings":"","what":"Purpose","title":"An introduction to the spinebil package","text":"main goal spinebil : Provide framework systematically comparing PPI functions. Facilitate visual diagnostics index behavior. Enable reproducible experiments simulated data understand well indices detect meaningful structure versus random noise.","code":""},{"path":"/articles/spinebil.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"An introduction to the spinebil package","text":"evaluate index behaviour known input distribution can trace value interpolating tour path, example moving nuisance structured projection.","code":"library(spinebil) ## sample from the spiral distribution d <- spiral_data(100, 4) ## the first two parameters are noise ## parameters 3 and 4 contain a spiral ## we write a list with the nuisance and structured plane m <- list(basis_matrix(1,2,4), basis_matrix(3,4,4)) ## the index functions to be evaluated should also be passed in a list index_list <- list(tourr::holes(), tourr::cmass()) index_labels <- c(\"holes\", \"cmass\") ## we can now compute the index traces and plot them trace <- get_trace(d, m, index_list, index_labels) Converting input data to the required matrix format. plot_trace(trace)"},{"path":"/articles/spinebil.html","id":"usage","dir":"Articles","previous_headings":"","what":"Usage","title":"An introduction to the spinebil package","text":"spinebil particularly useful researchers developers designing new projection pursuit indices wanting better understand strengths weaknesses existing ones. using tour-based visual diagnostics, helps bridge gap statistical rigor exploratory data analysis.","code":""},{"path":"/articles/utilsData.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"Generating Synthetic Structures and Noise","text":"vignette shows use two helpers package quick experiment data: data_gen()— generate structured 2D point sets (e.g., sine, circle, cluster) orthogonal polynomial features. noise_gen()— generate noise samples several distributions (Gaussian, uniform, heavy-tailed, microstructure, etc.). ’ll preview available structures, create simple polynomial features, sample noise types, combine structure + noise.","code":"library(tidyverse) library(spinebil)"},{"path":"/articles/utilsData.html","id":"what-the-function-does","dir":"Articles","previous_headings":"","what":"What the Function Does","title":"Generating Synthetic Structures and Noise","text":"Creates synthetic data benchmarking/visualisation. Structures (type like \"sine\", \"circle\", …) return tibble columns x, y, structure. Polynomial (type = \"polynomial\") returns n × degree matrix orthogonal polynomial basis vectors [0,1][0,1]. Generates numeric vector noise values (tibble value type) distributions : \"gaussian\", \"uniform\", \"lognormal\", \"t_distributed\", \"cauchy\", \"beta_noise\", \"exponential\", \"microstructure\".","code":""},{"path":"/articles/utilsData.html","id":"data_gen","dir":"Articles","previous_headings":"","what":"data_gen()","title":"Generating Synthetic Structures and Noise","text":"Creates synthetic data benchmarking/visualisation. Structures (type like \"sine\", \"circle\", …) return tibble columns x, y, structure. Polynomial (type = \"polynomial\") returns n × degree matrix orthogonal polynomial basis vectors [0,1][0,1].","code":""},{"path":"/articles/utilsData.html","id":"noise_gen","dir":"Articles","previous_headings":"","what":"noise_gen()","title":"Generating Synthetic Structures and Noise","text":"Generates numeric vector noise values (tibble value type) distributions : \"gaussian\", \"uniform\", \"lognormal\", \"t_distributed\", \"cauchy\", \"beta_noise\", \"exponential\", \"microstructure\".","code":""},{"path":"/articles/utilsData.html","id":"function-usage","dir":"Articles","previous_headings":"","what":"Function usage","title":"Generating Synthetic Structures and Noise","text":"type: \"linear\", \"sine\", \"circle\", \"cluster\", \"snake\", \"outliers\", \"sparse\", \"clumpy\", \"skewed\", \"striated\", \"concave\", \"monotonic\", \"doughnut\", \"\", \"polynomial\". n: number points/samples. seed: optional seed reproducibility. degree: \"polynomial\"; number basis columns. n: number noise samples. type: distribution name ( \"gaussian\", \"uniform\", \"lognormal\", \"t_distributed\", \"cauchy\", \"beta_noise\", \"exponential\", \"microstructure\"). level: scale/strength noise. seed: optional seed.","code":"data_gen(type, n, seed = NULL, degree = NULL, ...) noise_gen(n, type = \"gaussian\", level = 0.1, seed = NULL, ...)"},{"path":"/articles/utilsData.html","id":"example-usage","dir":"Articles","previous_headings":"","what":"Example usage","title":"Generating Synthetic Structures and Noise","text":"","code":"# One structure df_sine <- data_gen(\"sine\", n = 400, seed = 1)  # Multiple structures at once df_all  <- data_gen(\"all\",  n = 400, seed = 1) ggplot(df_all, aes(x, y)) +   geom_point(alpha = 0.6, size = 0.6) +   facet_wrap(~ structure, scales = \"free\") +   labs(title = \"Synthetic 2D Structures from data_gen()\",        subtitle = \"Each panel generated with n = 400\") # Generate a 4-degree orthogonal polynomial basis dPoly <- data_gen(\"polynomial\", n = 200, degree = 4, seed = 1)  ggplot(dPoly, aes(x = dPoly[,1] , y = dPoly[,2])) +   geom_point(alpha = 0.7) +    xlab(\"polynomial degree 1\") +   ylab(\"polynomial degree 2\")"},{"path":"/articles/utilsData.html","id":"preview-all-structures","dir":"Articles","previous_headings":"","what":"Preview all structures","title":"Generating Synthetic Structures and Noise","text":"","code":"ggplot(df_all, aes(x, y)) +   geom_point(alpha = 0.6, size = 0.6) +   facet_wrap(~ structure, scales = \"free\") +   labs(title = \"Synthetic 2D Structures from data_gen()\",        subtitle = \"Each panel generated with n = 400\")"},{"path":"/articles/utilsData.html","id":"polynomial-features-type-polynomial","dir":"Articles","previous_headings":"","what":"Polynomial features (type = \"polynomial\")","title":"Generating Synthetic Structures and Noise","text":"","code":"# Generate a 4-degree orthogonal polynomial basis dPoly <- data_gen(\"polynomial\", n = 200, degree = 4, seed = 1)  ggplot(dPoly, aes(x = dPoly[,1] , y = dPoly[,2])) +   geom_point(alpha = 0.7) +    xlab(\"polynomial degree 1\") +   ylab(\"polynomial degree 2\")"},{"path":"/articles/utilsData.html","id":"noise_gen-noise-distributions","dir":"Articles","previous_headings":"","what":"noise_gen(): noise distributions","title":"Generating Synthetic Structures and Noise","text":"","code":"eps_g <- noise_gen(n = 500, type = \"gaussian\",   level = 0.06, seed = 340) eps_t <- noise_gen(n = 500, type = \"t_distributed\", level = 0.15, seed = 341) eps_cau <- noise_gen(n = 500, type = \"cauchy\",     level = 0.04, seed = 342)"},{"path":"/articles/utilsData.html","id":"combining-structure-noise","dir":"Articles","previous_headings":"","what":"Combining structure + noise","title":"Generating Synthetic Structures and Noise","text":"simple example, let’s take clean sine wave add Gaussian noise y.","code":"set.seed(345) n <- 500 sine_clean <- data_gen(\"sine\", n = n) |> mutate(y = sin(x))   # Noise to add on y eps <- noise_gen(n = n, type = \"gaussian\", level = 0.06, seed = 123)$value sine_noisy <- sine_clean |> mutate(y = y + eps)  bind_rows(   sine_clean  |> mutate(which = \"clean\"),   sine_noisy  |> mutate(which = \"noisy (gaussian, level = 0.06)\") ) |>   ggplot(aes(x, y, color = which)) +   geom_point(alpha = 0.6, size = 0.6) +   labs(title = \"Sine Structure with and without Added Noise\",        color = NULL)"},{"path":"/articles/utilsData.html","id":"return-value","dir":"Articles","previous_headings":"","what":"Return value","title":"Generating Synthetic Structures and Noise","text":"data_gen(\"polynomial\", ...) returns n × degree matrix. data_gen(<type>, ...) return tibble columns x, y, structure. noise_gen(...) returns tibble columns value (numeric) type (factor/character).","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Ursula Laa. Author. Dianne Cook. Author. Tina Rashid Jafari. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Ursula Laa, Dianne Cook (2020). Using tours visually investigate properties new projection pursuit indexes application problems physics, Computational Statistics, 35:1171–1205 URL: https://doi.org/10.1007/s00180-020-00954-8","code":"@Article{,   title = {Using tours to visually investigate properties of new projection pursuit indexes with application to problems in physics},   author = {{Ursula Laa} and {Dianne Cook}},   journal = {Computational Statistics},   volume = {35},   pages = {1171–1205},   year = {2020},   url = {https://doi.org/10.1007/s00180-020-00954-8}, }"},{"path":"/index.html","id":"spinebil-","dir":"","previous_headings":"","what":"Investigating New Projection Pursuit Index Functions","title":"Investigating New Projection Pursuit Index Functions","text":"Studying Projection Pursuit INdex functions Exploration Based Interpolated tour paths Line graphs. spinebil provides functionalities evaluate performance projection pursuit index functions using tour methods presented paper.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Investigating New Projection Pursuit Index Functions","text":"can install released version spinebil CRAN : can install development version GitHub :","code":"install.packages(\"spinebil\") # install.packages(\"devtools\") devtools::install_github(\"uschiLaa/spinebil\")"},{"path":"/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Investigating New Projection Pursuit Index Functions","text":"evaluate index behaviour known input distribution can trace value interpolating tour path, example moving nuisance structured projection.","code":"library(spinebil) ## sample from the spiral distribution d <- spiral_data(100, 4) ## the first two parameters are noise ## parameters 3 and 4 contain a spiral ## we write a list with the nuisance and structured plane m <- list(basis_matrix(1,2,4), basis_matrix(3,4,4)) ## the index functions to be evaluated should also be passed in a list index_list <- list(tourr::holes(), tourr::cmass()) index_labels <- c(\"holes\", \"cmass\") ## we can now compute the index traces and plot them trace <- get_trace(d, m, index_list, index_labels) #> Converting input data to the required matrix format. plot_trace(trace)"},{"path":"/reference/basisMatrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate 2-d basis in directions i, j in n dimensions (i,j <= n) — basisMatrix","title":"Generate 2-d basis in directions i, j in n dimensions (i,j <= n) — basisMatrix","text":"Generate 2-d basis directions , j n dimensions (,j <= n)","code":""},{"path":"/reference/basisMatrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate 2-d basis in directions i, j in n dimensions (i,j <= n) — basisMatrix","text":"","code":"basisMatrix(i, j, n)"},{"path":"/reference/basisMatrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate 2-d basis in directions i, j in n dimensions (i,j <= n) — basisMatrix","text":"first basis direction j second basis direction n number dimensions","code":""},{"path":"/reference/basisMatrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate 2-d basis in directions i, j in n dimensions (i,j <= n) — basisMatrix","text":"basis matrix","code":""},{"path":"/reference/basisVector.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate basis vector in direction i in n dimensions (i <= n) — basisVector","title":"Generate basis vector in direction i in n dimensions (i <= n) — basisVector","text":"Generate basis vector direction n dimensions (<= n)","code":""},{"path":"/reference/basisVector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate basis vector in direction i in n dimensions (i <= n) — basisVector","text":"","code":"basisVector(i, n)"},{"path":"/reference/basisVector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate basis vector in direction i in n dimensions (i <= n) — basisVector","text":"selected direction n number dimensions","code":""},{"path":"/reference/basisVector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate basis vector in direction i in n dimensions (i <= n) — basisVector","text":"basis vector","code":""},{"path":"/reference/basis_matrix.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate 2-d basis in directions i, j in n dimensions (i,j <= n) — basis_matrix","title":"Generate 2-d basis in directions i, j in n dimensions (i,j <= n) — basis_matrix","text":"Generate 2-d basis directions , j n dimensions (,j <= n)","code":""},{"path":"/reference/basis_matrix.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate 2-d basis in directions i, j in n dimensions (i,j <= n) — basis_matrix","text":"","code":"basis_matrix(i, j, n)"},{"path":"/reference/basis_matrix.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate 2-d basis in directions i, j in n dimensions (i,j <= n) — basis_matrix","text":"first basis direction j second basis direction n number dimensions","code":""},{"path":"/reference/basis_matrix.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate 2-d basis in directions i, j in n dimensions (i,j <= n) — basis_matrix","text":"basis matrix","code":""},{"path":"/reference/basis_nearby.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate nearby bases, e.g. for simulated annealing. — basis_nearby","title":"Generate nearby bases, e.g. for simulated annealing. — basis_nearby","text":"Generate nearby bases, e.g. simulated annealing.","code":""},{"path":"/reference/basis_nearby.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate nearby bases, e.g. for simulated annealing. — basis_nearby","text":"","code":"basis_nearby(current, alpha = 0.5, method = \"linear\")"},{"path":"/reference/basis_vector.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate basis vector in direction i in n dimensions (i <= n) — basis_vector","title":"Generate basis vector in direction i in n dimensions (i <= n) — basis_vector","text":"Generate basis vector direction n dimensions (<= n)","code":""},{"path":"/reference/basis_vector.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate basis vector in direction i in n dimensions (i <= n) — basis_vector","text":"","code":"basis_vector(i, n)"},{"path":"/reference/basis_vector.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate basis vector in direction i in n dimensions (i <= n) — basis_vector","text":"selected direction n number dimensions","code":""},{"path":"/reference/basis_vector.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate basis vector in direction i in n dimensions (i <= n) — basis_vector","text":"basis vector","code":""},{"path":"/reference/compareSmoothing.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare traces with different smoothing options. — compareSmoothing","title":"Compare traces with different smoothing options. — compareSmoothing","text":"Compare traces different smoothing options.","code":""},{"path":"/reference/compareSmoothing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare traces with different smoothing options. — compareSmoothing","text":"","code":"compareSmoothing(d, tPath, idx, alphaV = c(0.01, 0.05, 0.1), n = 10)"},{"path":"/reference/compareSmoothing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare traces with different smoothing options. — compareSmoothing","text":"d Data matrix tPath Interpolated tour path (list projections) idx Index function alphaV Jitter amounts compare (jittering angle points) n Number evaluations entering mean value calculation","code":""},{"path":"/reference/compareSmoothing.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare traces with different smoothing options. — compareSmoothing","text":"Table mean index values","code":""},{"path":"/reference/compareSmoothing.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compare traces with different smoothing options. — compareSmoothing","text":"","code":"d <- spiralData(3, 30) tPath <- tourr::save_history(d, max_bases=2) tPath <- as.list(tourr::interpolate(tPath, 0.3)) idx <- scagIndex(\"stringy\") compS <- compareSmoothing(d, tPath, idx, alphaV = c(0.01, 0.05), n=2) plotSmoothingComparison(compS)"},{"path":"/reference/compare_smoothing.html","id":null,"dir":"Reference","previous_headings":"","what":"Compare traces with different smoothing options. — compare_smoothing","title":"Compare traces with different smoothing options. — compare_smoothing","text":"Compare traces different smoothing options.","code":""},{"path":"/reference/compare_smoothing.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compare traces with different smoothing options. — compare_smoothing","text":"","code":"compare_smoothing(d, tPath, idx, alphaV = c(0.01, 0.05, 0.1), n = 10)"},{"path":"/reference/compare_smoothing.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compare traces with different smoothing options. — compare_smoothing","text":"d Data matrix tPath Interpolated tour path (list projections) idx Index function alphaV Jitter amounts compare (jittering angle points) n Number evaluations entering mean value calculation","code":""},{"path":"/reference/compare_smoothing.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compare traces with different smoothing options. — compare_smoothing","text":"Table mean index values","code":""},{"path":"/reference/compare_smoothing.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Compare traces with different smoothing options. — compare_smoothing","text":"","code":"d <- spiral_data(30, 3) tPath <- tourr::save_history(d, max_bases=2) #> Converting input data to the required matrix format. tPath <- as.list(tourr::interpolate(tPath, 0.3)) idx <- scag_index(\"stringy\") compS <- compare_smoothing(d, tPath, idx, alphaV = c(0.01, 0.05), n=2) #> Error in d %*% proj: requires numeric/complex matrix/vector arguments plot_smoothing_comparison(compS) #> Error: object 'compS' not found"},{"path":"/reference/data_gen.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Synthetic Data with Various Structures — data_gen","title":"Generate Synthetic Data with Various Structures — data_gen","text":"Generates either: Structured (x, y) scatter data (linear, sine, circle, etc.), matrix scaled orthogonal polynomial features.","code":""},{"path":"/reference/data_gen.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Synthetic Data with Various Structures — data_gen","text":"","code":"data_gen(type = \"all\", n = 500, degree = NULL, seed = NULL)"},{"path":"/reference/data_gen.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Synthetic Data with Various Structures — data_gen","text":"type Character string. Options: \"polynomial\" orthogonal polynomial features \"linear\", \"sine\", \"circle\", \"cluster\", \"snake\", \"outliers\", \"sparse\", \"clumpy\", \"skewed\", \"striated\", \"concave\", \"monotonic\", \"doughnut\", \"\" generate scatter structures. n Integer. Number samples generate. Default 500. degree Integer. Degree polynomial features (type = \"polynomial\"). seed Optional integer. Sets random seed reproducibility.","code":""},{"path":"/reference/data_gen.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Synthetic Data with Various Structures — data_gen","text":"type = \"polynomial\", returns matrix (n x degree). Otherwise tibble columns: x: Numeric vector x-values y: Numeric vector y-values structure: Character name structure type","code":""},{"path":"/reference/data_gen.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Synthetic Data with Various Structures — data_gen","text":"","code":"data_gen(\"linear\", n = 200) #> # A tibble: 200 × 3 #>         x      y structure #>     <dbl>  <dbl> <chr>     #>  1  0.543  0.536 linear    #>  2 -0.890 -0.882 linear    #>  3 -1.54  -1.54  linear    #>  4  1.26   1.24  linear    #>  5 -1.45  -1.43  linear    #>  6  1.54   1.56  linear    #>  7  0.298  0.308 linear    #>  8 -1.12  -1.11  linear    #>  9  1.26   1.25  linear    #> 10 -1.56  -1.58  linear    #> # ℹ 190 more rows data_gen(\"polynomial\", degree = 4, n = 200) #>                   1            2            3           4 #>   [1,]  1.329043217  0.720433574 -0.308849982 -1.18946790 #>   [2,] -1.371922092  1.187353508 -0.628946490 -0.13102446 #>   [3,] -0.157840970 -1.093256438  0.474523980  0.97861343 #>   [4,]  1.703584333  1.977026593  2.030174511  1.99532032 #>   [5,]  0.322263322 -1.062086976 -0.631698680  0.85977172 #>   [6,]  0.951576126 -0.220364238 -1.206519954 -1.06783925 #>   [7,] -0.804648316 -0.299138643  1.143078050 -0.85607993 #>   [8,]  0.515056142 -0.900758369 -0.990069639  0.35645880 #>   [9,] -1.058637550  0.275143086  0.719327990 -1.21915030 #>  [10,] -0.110548115 -1.113665796  0.369370617  1.04553459 #>  [11,] -1.071465251  0.308073222  0.683420658 -1.21541173 #>  [12,] -1.230632602  0.748076346  0.106043669 -0.90998567 #>  [13,] -0.375808132 -0.932869537  0.893666650  0.48453493 #>  [14,]  1.610743951  1.635545078  1.292528153  0.75081399 #>  [15,]  1.366674139  0.832142958 -0.146170966 -1.06143637 #>  [16,] -0.744256755 -0.413908185  1.171790042 -0.68637856 #>  [17,]  0.618451725 -0.779107941 -1.129768773  0.01931742 #>  [18,] -1.218324704  0.711978919  0.159786265 -0.95293932 #>  [19,] -0.542583869 -0.736546737  1.104098867 -0.03601880 #>  [20,]  0.501002171 -0.915400187 -0.967851630  0.39947435 #>  [21,] -0.102974387 -1.116457591  0.352213776  1.05473766 #>  [22,]  0.793387315 -0.517434885 -1.251562667 -0.58401496 #>  [23,]  1.416821201  0.986056447  0.094015891 -0.83547212 #>  [24,] -1.278556881  0.891943067 -0.118554697 -0.70701907 #>  [25,]  0.526218307 -0.888806445 -1.007200474  0.32173512 #>  [26,]  1.250547209  0.497870346 -0.601785417 -1.35437498 #>  [27,] -0.386792278 -0.921902317  0.910998079  0.45297968 #>  [28,]  0.500527905 -0.915886387 -0.967089481  0.40091175 #>  [29,] -0.055805475 -1.130882820  0.243748797  1.10236360 #>  [30,] -1.075797748  0.319280506  0.670950696 -1.21353198 #>  [31,]  0.126417545 -1.138661346 -0.187952220  1.12338056 #>  [32,] -1.144906955  0.503873973  0.448067457 -1.13819457 #>  [33,]  0.594439512 -0.809546147 -1.101296493  0.10029077 #>  [34,] -1.103645240  0.392344226  0.586616857 -1.19371735 #>  [35,]  0.107354560 -1.141415430 -0.142733963  1.13348246 #>  [36,] -1.341800775  1.089863520 -0.453479823 -0.34478524 #>  [37,]  0.089230835 -1.143260720 -0.099623393  1.14042542 #>  [38,] -1.504055904  1.639607843 -1.526827054  1.16558335 #>  [39,]  1.190425108  0.336963364 -0.785717915 -1.39882214 #>  [40,] -0.655316759 -0.567696676  1.170939071 -0.40825370 #>  [41,] -0.789909277 -0.327920908  1.152393579 -0.81656193 #>  [42,] -0.271079368 -1.023535903  0.708292554  0.75647614 #>  [43,]  0.531985422 -0.882519295 -1.015868485  0.30360951 #>  [44,]  1.617673245  1.660349243  1.343757548  0.83168125 #>  [45,] -0.469614164 -0.830296075  1.026684707  0.20082361 #>  [46,]  0.515770085 -0.900002469 -0.991179155  0.35425233 #>  [47,]  1.193452538  0.344867510 -0.777262896 -1.39810416 #>  [48,] -1.138564272  0.486475745  0.470439553 -1.14886649 #>  [49,]  1.681343289  1.893419370  1.843235010  1.66446050 #>  [50,] -1.341222590  1.088012540 -0.450213889 -0.34861819 #>  [51,] -0.811485518 -0.285617794  1.138237244 -0.87394139 #>  [52,]  0.555281088 -0.856346374 -1.049576683  0.22919214 #>  [53,]  0.090494675 -1.143156483 -0.102632431  1.14002561 #>  [54,] -0.776968291 -0.352781055  1.159328051 -0.78079079 #>  [55,]  1.722147216  2.047675941  2.191246370  2.28812574 #>  [56,]  0.615985731 -0.782294816 -1.126962698  0.02768970 #>  [57,] -1.328152896  1.046376322 -0.377404737 -0.43261564 #>  [58,]  0.526668421 -0.888318489 -1.007881520  0.32032490 #>  [59,]  1.371328905  0.846186658 -0.125014122 -1.04319986 #>  [60,]  1.554905325  1.439685038  0.901523731  0.16469367 #>  [61,] -0.197351350 -1.072271525  0.559318043  0.91062947 #>  [62,]  0.063616408 -1.144583565 -0.038590283  1.14579776 #>  [63,] -0.426440472 -0.880012455  0.969800373  0.33513846 #>  [64,] -0.783103274 -0.341043406  1.156184461 -0.79786925 #>  [65,]  1.652489019  1.786643274  1.610396529  1.26657953 #>  [66,] -0.401551113 -0.906730404  0.933587213  0.40980705 #>  [67,] -0.953763214  0.020078615  0.958080980 -1.15790093 #>  [68,]  0.855107447 -0.408357435 -1.253431887 -0.78649859 #>  [69,] -1.059605459  0.277614649  0.716671236 -1.21896214 #>  [70,] -0.859442818 -0.187765932  1.094781728 -0.98981885 #>  [71,]  1.264204306  0.535577159 -0.555203981 -1.33488409 #>  [72,] -0.449942765 -0.853478871  1.001729880  0.26270469 #>  [73,] -1.405437650  1.298275767 -0.836649867  0.14054840 #>  [74,] -1.543685882  1.783057604 -1.838675108  1.68165449 #>  [75,] -1.231429197  0.750424629  0.102510530 -0.90708055 #>  [76,] -1.589393430  1.952980837 -2.223881412  2.35825991 #>  [77,]  0.887504748 -0.347604309 -1.244720687 -0.88677995 #>  [78,]  1.533222269  1.365557524  0.759962315 -0.03286037 #>  [79,]  1.732976530  2.089256853  2.287356883  2.46612016 #>  [80,] -0.246117356 -1.041432621  0.659349490  0.81245503 #>  [81,] -0.711201941 -0.473183130  1.177239317 -0.58606069 #>  [82,]  0.038672889 -1.144425171  0.020844475  1.14602320 #>  [83,] -1.461207689  1.488562810 -1.212175064  0.67673720 #>  [84,] -1.627878012  2.099768529 -2.569969455  2.99974242 #>  [85,]  0.064559112 -1.144561559 -0.040837344  1.14569235 #>  [86,] -0.800061968 -0.308148236  1.146140013 -0.84392862 #>  [87,] -0.759040785 -0.386585709  1.167045948 -0.72971331 #>  [88,]  0.258324738 -1.096761064 -0.492722861  0.97668758 #>  [89,] -0.773351337 -0.359660669  1.161060657 -0.77062352 #>  [90,]  0.519489309 -0.896045760 -0.996928707  0.34272559 #>  [91,] -0.551957673 -0.723618140  1.112206531 -0.06699238 #>  [92,]  1.535142037  1.372077082  0.772267868 -0.01602000 #>  [93,]  1.473295593  1.166297133  0.397696225 -0.49783148 #>  [94,] -1.320877284  1.023368152 -0.337712661 -0.47720777 #>  [95,]  0.894591306 -0.333994259 -1.241887397 -0.90801952 #>  [96,]  0.318089143 -1.064636809 -0.622864975  0.86825692 #>  [97,]  0.752891352 -0.584254839 -1.237933905 -0.44573669 #>  [98,]  0.767569981 -0.560469222 -1.243964419 -0.49619931 #>  [99,] -1.499360407  1.622850161 -1.491215267  1.10858857 #> [100,] -0.156060619 -1.094117700  0.470633106  0.98142262 #> [101,]  1.156801558  0.250591131 -0.874026127 -1.39680201 #> [102,]  0.307268617 -1.071060501 -0.599799432  0.88971060 #> [103,]  0.381575136 -1.021536517 -0.752978682  0.72711091 #> [104,]  1.383477382  0.883073486 -0.068709186 -0.99302278 #> [105,]  0.831206320 -0.451634565 -1.255512328 -0.70961120 #> [106,]  1.575993499  1.512813482  1.044670794  0.37264682 #> [107,] -0.163232960 -1.090603649  0.486272874  0.96996984 #> [108,] -0.654624662 -0.568822241  1.170743592 -0.40600401 #> [109,]  1.007274681 -0.102099579 -1.149299158 -1.20096580 #> [110,]  0.478490238 -0.937909495 -0.930808025  0.46662992 #> [111,] -1.089991325  0.356298019  0.628875905 -1.20513127 #> [112,] -0.258714631 -1.032579575  0.684253254  0.78467084 #> [113,] -1.630726452  2.110768089 -2.596389572  3.04993981 #> [114,] -0.202564999 -1.069234957  0.570270348  0.90086887 #> [115,]  0.984260431 -0.151828551 -1.175748598 -1.14911501 #> [116,]  1.089037574  0.084399908 -1.021775483 -1.34206510 #> [117,] -0.804193126 -0.300034991  1.143388576 -0.85487995 #> [118,]  0.967919826 -0.186399500 -1.192114899 -1.10953965 #> [119,] -1.536534434  1.756904871 -1.780896581  1.58380641 #> [120,] -0.136100987 -1.103275618  0.426634951  1.01137825 #> [121,]  0.183166117 -1.125527695 -0.321246713  1.07649264 #> [122,] -0.161861683 -1.091284623  0.483289968  0.97218735 #> [123,]  1.139874346  0.208090028 -0.914660088 -1.38917214 #> [124,]  1.528432862  1.349329492  0.729454529 -0.07433055 #> [125,]  0.679256493 -0.696115118 -1.189975793 -0.19002484 #> [126,] -1.314021893  1.001799995 -0.300858713 -0.51782938 #> [127,] -0.958987524  0.032187460  0.948419789 -1.16442175 #> [128,] -0.005043079 -1.140704552  0.124626719  1.13452781 #> [129,]  0.814238208 -0.481562791 -1.254818269 -0.65378622 #> [130,]  0.209476936 -1.116931618 -0.382076282  1.04635002 #> [131,]  1.366578934  0.831856238 -0.146601293 -1.06180371 #> [132,] -0.629245928 -0.609336963  1.161664370 -0.32295555 #> [133,] -0.865329126 -0.175391976  1.088275944 -1.00279673 #> [134,]  0.733781217 -0.614480693 -1.228276901 -0.37963219 #> [135,] -0.564945688 -0.705371571  1.122711445 -0.11000934 #> [136,]  0.021553347 -1.143490438  0.061570545  1.14332150 #> [137,] -1.218557925  0.712659695  0.158782635 -0.95215883 #> [138,]  0.730657468 -0.619341753 -1.226507599 -0.36879423 #> [139,] -0.553275314 -0.721784655  1.113311070 -0.07135177 #> [140,]  1.163512597  0.267623282 -0.857213176 -1.39863122 #> [141,]  0.236358434 -1.106508878 -0.443376860  1.01018498 #> [142,]  1.613345184  1.644843563  1.311688513  0.78095427 #> [143,] -1.504211909  1.640165474 -1.528015052  1.16749175 #> [144,]  0.585332282 -0.820744601 -1.089840586  0.13064886 #> [145,] -1.363245976  1.159059154 -0.577328547 -0.19546581 #> [146,] -0.151229297 -1.096418258  0.460046047  0.98893329 #> [147,]  0.973827670 -0.173971289 -1.186426275 -1.12410021 #> [148,] -0.628650996 -0.610268989  1.161407458 -0.32099763 #> [149,] -1.268178449  0.860340456 -0.067819278 -0.75595774 #> [150,] -1.385971199  1.233536368 -0.714397315 -0.02162187 #> [151,] -0.414056957 -0.893483417  0.952083743  0.37256881 #> [152,]  0.324333592 -1.060807505 -0.636066383  0.85552047 #> [153,]  0.689426342 -0.681406252 -1.198288375 -0.22538216 #> [154,]  0.733099488 -0.615543484 -1.227895295 -0.37726754 #> [155,] -0.355409227 -0.952502662  0.860343630  0.54175017 #> [156,] -1.300266280  0.958847862 -0.228495961 -0.59532538 #> [157,] -1.296727249  0.947867387 -0.210218955 -0.61441015 #> [158,]  1.021539846 -0.070665527 -1.130870334 -1.23065130 #> [159,] -1.116677407  0.427147956  0.544631099 -1.17966940 #> [160,] -0.282698336 -1.014718036  0.730502686  0.72916955 #> [161,]  1.571086282  1.495705413  1.010874910  0.32283460 #> [162,]  0.900746937 -0.322078592 -1.239150966 -0.92624653 #> [163,]  0.544250113 -0.868894980 -1.033879313  0.26466274 #> [164,] -0.476129930 -0.822421499  1.034583373  0.18010283 #> [165,]  1.665141893  1.833230469  1.711162311  1.43677578 #> [166,] -1.252885465  0.814223238  0.004816930 -0.82297483 #> [167,]  0.595079512 -0.808752032 -1.102088152  0.09814958 #> [168,]  1.737507985  2.106735958  2.328045660  2.54219527 #> [169,] -1.021887527  0.182891668  0.813940206 -1.21544308 #> [170,] -1.163074584  0.554219286  0.381789845 -1.10312641 #> [171,] -1.442353503  1.423434041 -1.080974566  0.48321994 #> [172,]  0.237909615 -1.105856848 -0.446884733  1.00793493 #> [173,] -0.036055417 -1.135406738  0.197641505  1.11725872 #> [174,]  1.438602384  1.054705308  0.206901450 -0.71616277 #> [175,] -1.572803573  1.890751961 -2.080861016  2.10225801 #> [176,]  1.282845944  0.587736797 -0.488677605 -1.30224177 #> [177,]  0.083731008 -1.143671655 -0.086525389  1.14201783 #> [178,] -1.066365749  0.294937027  0.697876207 -1.21722236 #> [179,] -0.397962942 -0.910464981  0.928170202  0.42038222 #> [180,]  0.600276356 -0.802268975 -1.108450739  0.08072661 #> [181,]  1.362441218  0.819415141 -0.165211065 -1.07755107 #> [182,]  0.862038122 -0.395563130 -1.252145794 -0.80836045 #> [183,] -0.221409053 -1.057739648  0.609356530  0.86410232 #> [184,] -1.090147295  0.356707364  0.628403094 -1.20501956 #> [185,]  1.264765183  0.537134870 -0.553252157 -1.33400477 #> [186,]  1.397405231  0.925779687 -0.002207075 -0.93080873 #> [187,] -0.277924755 -1.018378285  0.721423115  0.74048222 #> [188,] -1.505534751  1.644896147 -1.538101167  1.18371244 #> [189,]  1.627337227  1.695126465  1.416218977  0.94757669 #> [190,]  1.052159766 -0.001616359 -1.085928995 -1.28745645 #> [191,] -0.883598602 -0.136480401  1.066408681 -1.04115594 #> [192,] -0.501130546 -0.791303381  1.063140085  0.09970291 #> [193,] -1.026580978  0.194500775  0.802529828 -1.21705924 #> [194,] -0.392782267 -0.915804929  0.920263791  0.43556209 #> [195,] -0.293515690 -1.006230129  0.750838739  0.70305756 #> [196,]  1.464327210  1.137185393  0.347065786 -0.55770074 #> [197,] -0.688004530 -0.513284619  1.176932963 -0.51329778 #> [198,] -1.158310119  0.540942962  0.399487832 -1.11297820 #> [199,] -0.088090115 -1.121560725  0.318272874  1.07157989 #> [200,] -1.257894125  0.829268166 -0.018695147 -0.80168537 #> attr(,\"coefs\") #> attr(,\"coefs\")$alpha #> [1] 0.4770152 0.5084470 0.5013686 0.4914184 #>  #> attr(,\"coefs\")$norm2 #> [1]   1.00000000 200.00000000  16.91032938   1.09207845   0.06643508 #> [6]   0.00402836 #>  #> attr(,\"degree\") #> [1] 1 2 3 4 #> attr(,\"class\") #> [1] \"poly\"   \"matrix\" data_gen(\"all\", n = 200) #> # A tibble: 2,602 × 3 #>         x       y structure #>     <dbl>   <dbl> <chr>     #>  1  1.33   1.34   linear    #>  2  0.101  0.0971 linear    #>  3  0.826  0.814  linear    #>  4  0.756  0.735  linear    #>  5 -0.851 -0.864  linear    #>  6  0.595  0.586  linear    #>  7 -1.04  -1.03   linear    #>  8  0.654  0.661  linear    #>  9 -1.10  -1.06   linear    #> 10  0.978  0.964  linear    #> # ℹ 2,592 more rows"},{"path":"/reference/distanceDist.html","id":null,"dir":"Reference","previous_headings":"","what":"Collecting all pairwise distances between input planes. — distanceDist","title":"Collecting all pairwise distances between input planes. — distanceDist","text":"distribution pairwise distances useful understand optimisation guided tour, compare e.g. different optimisation methods different number noise dimensions.","code":""},{"path":"/reference/distanceDist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Collecting all pairwise distances between input planes. — distanceDist","text":"","code":"distanceDist(planes, nn = FALSE)"},{"path":"/reference/distanceDist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Collecting all pairwise distances between input planes. — distanceDist","text":"planes Input planes (e.g. result guided tour) nn Set true consider nearest neighbour distances (dummy, yet implemented)","code":""},{"path":"/reference/distanceDist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Collecting all pairwise distances between input planes. — distanceDist","text":"numeric vector containing distances","code":""},{"path":"/reference/distanceDist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Collecting all pairwise distances between input planes. — distanceDist","text":"","code":"planes1 <- purrr::rerun(10, tourr::basis_random(5)) #> Warning: `rerun()` was deprecated in purrr 1.0.0. #> ℹ Please use `map()` instead. #>   # Previously #>   rerun(10, tourr::basis_random(5)) #>  #>   # Now #>   map(1:10, ~ tourr::basis_random(5)) planes2 <- purrr::rerun(10, tourr::basis_random(10)) #> Warning: `rerun()` was deprecated in purrr 1.0.0. #> ℹ Please use `map()` instead. #>   # Previously #>   rerun(10, tourr::basis_random(10)) #>  #>   # Now #>   map(1:10, ~ tourr::basis_random(10)) d1 <- distanceDist(planes1) d2 <- distanceDist(planes2) d <- tibble::tibble(dist=c(d1, d2), dim=c(rep(5,length(d1)),rep(10,length(d2)))) ggplot2::ggplot(d) + ggplot2::geom_boxplot(ggplot2::aes(factor(dim), dist))"},{"path":"/reference/distanceToSp.html","id":null,"dir":"Reference","previous_headings":"","what":"Collecting distances between input planes and input special plane. — distanceToSp","title":"Collecting distances between input planes and input special plane. — distanceToSp","text":"optimal view known, can use distance given plane optimal one proxy diagnose performance guided tour.","code":""},{"path":"/reference/distanceToSp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Collecting distances between input planes and input special plane. — distanceToSp","text":"","code":"distanceToSp(planes, specialPlane)"},{"path":"/reference/distanceToSp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Collecting distances between input planes and input special plane. — distanceToSp","text":"planes Input planes (e.g. result guided tour) specialPlane Plane defining optimal view","code":""},{"path":"/reference/distanceToSp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Collecting distances between input planes and input special plane. — distanceToSp","text":"numeric vector containing distances","code":""},{"path":"/reference/distanceToSp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Collecting distances between input planes and input special plane. — distanceToSp","text":"","code":"planes <- purrr::rerun(10, tourr::basis_random(5)) specialPlane <- basisMatrix(1,2,5) d <- distanceToSp(planes, specialPlane) plot(d)"},{"path":"/reference/distance_dist.html","id":null,"dir":"Reference","previous_headings":"","what":"Collecting all pairwise distances between input planes. — distance_dist","title":"Collecting all pairwise distances between input planes. — distance_dist","text":"distribution pairwise distances useful understand optimisation guided tour, compare e.g. different optimisation methods different number noise dimensions.","code":""},{"path":"/reference/distance_dist.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Collecting all pairwise distances between input planes. — distance_dist","text":"","code":"distance_dist(planes, nn = FALSE)"},{"path":"/reference/distance_dist.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Collecting all pairwise distances between input planes. — distance_dist","text":"planes Input planes (e.g. result guided tour) nn Set true consider nearest neighbour distances (dummy, yet implemented)","code":""},{"path":"/reference/distance_dist.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Collecting all pairwise distances between input planes. — distance_dist","text":"numeric vector containing distances","code":""},{"path":"/reference/distance_dist.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Collecting all pairwise distances between input planes. — distance_dist","text":"","code":"planes1 <- purrr::rerun(10, tourr::basis_random(5)) #> Warning: `rerun()` was deprecated in purrr 1.0.0. #> ℹ Please use `map()` instead. #>   # Previously #>   rerun(10, tourr::basis_random(5)) #>  #>   # Now #>   map(1:10, ~ tourr::basis_random(5)) planes2 <- purrr::rerun(10, tourr::basis_random(10)) #> Warning: `rerun()` was deprecated in purrr 1.0.0. #> ℹ Please use `map()` instead. #>   # Previously #>   rerun(10, tourr::basis_random(10)) #>  #>   # Now #>   map(1:10, ~ tourr::basis_random(10)) d1 <- distance_dist(planes1) d2 <- distance_dist(planes2) d <- tibble::tibble(dist=c(d1, d2), dim=c(rep(5,length(d1)),rep(10,length(d2)))) ggplot2::ggplot(d) + ggplot2::geom_boxplot(ggplot2::aes(factor(dim), dist))"},{"path":"/reference/distance_to_sp.html","id":null,"dir":"Reference","previous_headings":"","what":"Collecting distances between input planes and input special plane. — distance_to_sp","title":"Collecting distances between input planes and input special plane. — distance_to_sp","text":"optimal view known, can use distance given plane optimal one proxy diagnose performance guided tour.","code":""},{"path":"/reference/distance_to_sp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Collecting distances between input planes and input special plane. — distance_to_sp","text":"","code":"distance_to_sp(planes, special_plane)"},{"path":"/reference/distance_to_sp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Collecting distances between input planes and input special plane. — distance_to_sp","text":"planes Input planes (e.g. result guided tour) special_plane Plane defining optimal view","code":""},{"path":"/reference/distance_to_sp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Collecting distances between input planes and input special plane. — distance_to_sp","text":"numeric vector containing distances","code":""},{"path":"/reference/distance_to_sp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Collecting distances between input planes and input special plane. — distance_to_sp","text":"","code":"planes <- purrr::rerun(10, tourr::basis_random(5)) special_plane <- basis_matrix(1,2,5) d <- distance_to_sp(planes, special_plane) plot(d)"},{"path":"/reference/geodesic_info.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate information required to interpolate along a geodesic path between two frames. — geodesic_info","title":"Calculate information required to interpolate along a geodesic path between two frames. — geodesic_info","text":"methdology outlined http://www-stat.wharton.upenn.edu/~buja/PAPERS/paper-dyn-proj-algs.pdf http://www-stat.wharton.upenn.edu/~buja/PAPERS/paper-dyn-proj-math.pdf, code follows notation outlined papers:","code":""},{"path":"/reference/geodesic_info.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate information required to interpolate along a geodesic path between two frames. — geodesic_info","text":"","code":"geodesic_info(Fa, Fz, epsilon = 1e-06)"},{"path":"/reference/geodesic_info.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate information required to interpolate along a geodesic path between two frames. — geodesic_info","text":"Fa starting frame, orthonormalised necessary Fz target frame, orthonormalised necessary epsilon epsilon used determine angle effectively equal 0","code":""},{"path":"/reference/geodesic_info.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate information required to interpolate along a geodesic path between two frames. — geodesic_info","text":"p = dimension data d = target dimension F = frame, orthonormal p x d matrix Fa = starting frame, Fz = target frame Fa'Fz = Va lamda  Vz' (svd) Ga = Fa Va, Gz = Fz Vz tau = principle angles","code":""},{"path":"/reference/getIndexMean.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate mean index value over n jittered views. — getIndexMean","title":"Evaluate mean index value over n jittered views. — getIndexMean","text":"Evaluate mean index value n jittered views.","code":""},{"path":"/reference/getIndexMean.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate mean index value over n jittered views. — getIndexMean","text":"","code":"getIndexMean(proj, d, alpha, idx, method = \"jitterAngle\", n = 10)"},{"path":"/reference/getIndexMean.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate mean index value over n jittered views. — getIndexMean","text":"proj Original projection plane d Data matrix alpha Jitter amount (jittering angle points) idx Index function method Select \"jitterAngle\" (default) \"jitterPoints\" (otherwise return original index value) n Number evaluations entering mean value calculation","code":""},{"path":"/reference/getIndexMean.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate mean index value over n jittered views. — getIndexMean","text":"Mean index value","code":""},{"path":"/reference/getTrace.html","id":null,"dir":"Reference","previous_headings":"","what":"Tracing the index over an interpolated planned tour path. — getTrace","title":"Tracing the index over an interpolated planned tour path. — getTrace","text":"Tracing used test index value varies smoothly interpolated tour path. index value calculated data d projection interpolated sequence. Note index functions must take data 2-d matrix format return index value.","code":""},{"path":"/reference/getTrace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tracing the index over an interpolated planned tour path. — getTrace","text":"","code":"getTrace(d, m, indexList, indexLabels)"},{"path":"/reference/getTrace.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tracing the index over an interpolated planned tour path. — getTrace","text":"d data m list projection matrices planned tour indexList list index functions calculate entry indexLabels labels used output","code":""},{"path":"/reference/getTrace.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tracing the index over an interpolated planned tour path. — getTrace","text":"index values interpolation step","code":""},{"path":"/reference/getTrace.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tracing the index over an interpolated planned tour path. — getTrace","text":"","code":"d <- spiralData(4, 100) m <- list(basisMatrix(1,2,4), basisMatrix(3,4,4)) indexList <- list(tourr::holes(), tourr::cmass()) indexLabels <- c(\"holes\", \"cmass\") trace <- getTrace(d, m, indexList, indexLabels) plotTrace(trace)"},{"path":"/reference/get_index_mean.html","id":null,"dir":"Reference","previous_headings":"","what":"Evaluate mean index value over n jittered views. — get_index_mean","title":"Evaluate mean index value over n jittered views. — get_index_mean","text":"Evaluate mean index value n jittered views.","code":""},{"path":"/reference/get_index_mean.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Evaluate mean index value over n jittered views. — get_index_mean","text":"","code":"get_index_mean(proj, d, alpha, idx, method = \"jitter_angle\", n = 10)"},{"path":"/reference/get_index_mean.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Evaluate mean index value over n jittered views. — get_index_mean","text":"proj Original projection plane d Data matrix alpha Jitter amount (jittering angle points) idx Index function method Select \"jitterAngle\" (default) \"jitterPoints\" (otherwise return original index value) n Number evaluations entering mean value calculation","code":""},{"path":"/reference/get_index_mean.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Evaluate mean index value over n jittered views. — get_index_mean","text":"Mean index value","code":""},{"path":"/reference/get_trace.html","id":null,"dir":"Reference","previous_headings":"","what":"Tracing the index over an interpolated planned tour path. — get_trace","title":"Tracing the index over an interpolated planned tour path. — get_trace","text":"Tracing used test index value varies smoothly interpolated tour path. index value calculated data d projection interpolated sequence. Note index functions must take data 2-d matrix format return index value.","code":""},{"path":"/reference/get_trace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tracing the index over an interpolated planned tour path. — get_trace","text":"","code":"get_trace(d, m, index_list, index_labels)"},{"path":"/reference/get_trace.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tracing the index over an interpolated planned tour path. — get_trace","text":"d data m list projection matrices planned tour index_list list index functions calculate entry index_labels labels used output","code":""},{"path":"/reference/get_trace.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tracing the index over an interpolated planned tour path. — get_trace","text":"index values interpolation step","code":""},{"path":"/reference/get_trace.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tracing the index over an interpolated planned tour path. — get_trace","text":"","code":"d <- spiral_data(100, 4) m <- list(basis_matrix(1,2,4), basis_matrix(3,4,4)) index_list <- list(tourr::holes(), tourr::cmass()) index_labels <- c(\"holes\", \"cmass\") trace <- get_trace(d, m, index_list, index_labels) #> Converting input data to the required matrix format. plot_trace(trace)"},{"path":"/reference/jitterAngle.html","id":null,"dir":"Reference","previous_headings":"","what":"Re-evaluate index after jittering the projection by an angle alpha. — jitterAngle","title":"Re-evaluate index after jittering the projection by an angle alpha. — jitterAngle","text":"Re-evaluate index jittering projection angle alpha.","code":""},{"path":"/reference/jitterAngle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Re-evaluate index after jittering the projection by an angle alpha. — jitterAngle","text":"","code":"jitterAngle(proj, d, alpha, idx)"},{"path":"/reference/jitterAngle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Re-evaluate index after jittering the projection by an angle alpha. — jitterAngle","text":"proj Original projection plane d Data matrix alpha Jitter angle idx Index function","code":""},{"path":"/reference/jitterAngle.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Re-evaluate index after jittering the projection by an angle alpha. — jitterAngle","text":"New index value","code":""},{"path":"/reference/jitterPoints.html","id":null,"dir":"Reference","previous_headings":"","what":"Re-evaluate index after jittering all points by an amount alpha. — jitterPoints","title":"Re-evaluate index after jittering all points by an amount alpha. — jitterPoints","text":"Re-evaluate index jittering points amount alpha.","code":""},{"path":"/reference/jitterPoints.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Re-evaluate index after jittering all points by an amount alpha. — jitterPoints","text":"","code":"jitterPoints(projData, alpha, idx)"},{"path":"/reference/jitterPoints.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Re-evaluate index after jittering all points by an amount alpha. — jitterPoints","text":"projData Original projected data points alpha Jitter amount (passed jitter() function) idx Index function","code":""},{"path":"/reference/jitterPoints.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Re-evaluate index after jittering all points by an amount alpha. — jitterPoints","text":"New index value","code":""},{"path":"/reference/jitter_angle.html","id":null,"dir":"Reference","previous_headings":"","what":"Re-evaluate index after jittering the projection by an angle alpha. — jitter_angle","title":"Re-evaluate index after jittering the projection by an angle alpha. — jitter_angle","text":"Re-evaluate index jittering projection angle alpha.","code":""},{"path":"/reference/jitter_angle.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Re-evaluate index after jittering the projection by an angle alpha. — jitter_angle","text":"","code":"jitter_angle(proj, d, alpha, idx)"},{"path":"/reference/jitter_angle.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Re-evaluate index after jittering the projection by an angle alpha. — jitter_angle","text":"proj Original projection plane d Data matrix alpha Jitter angle idx Index function","code":""},{"path":"/reference/jitter_angle.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Re-evaluate index after jittering the projection by an angle alpha. — jitter_angle","text":"New index value","code":""},{"path":"/reference/jitter_points.html","id":null,"dir":"Reference","previous_headings":"","what":"Re-evaluate index after jittering all points by an amount alpha. — jitter_points","title":"Re-evaluate index after jittering all points by an amount alpha. — jitter_points","text":"Re-evaluate index jittering points amount alpha.","code":""},{"path":"/reference/jitter_points.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Re-evaluate index after jittering all points by an amount alpha. — jitter_points","text":"","code":"jitter_points(proj_data, alpha, idx)"},{"path":"/reference/jitter_points.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Re-evaluate index after jittering all points by an amount alpha. — jitter_points","text":"proj_data Original projected data points alpha Jitter amount (passed jitter() function) idx Index function","code":""},{"path":"/reference/jitter_points.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Re-evaluate index after jittering all points by an amount alpha. — jitter_points","text":"New index value","code":""},{"path":"/reference/noise_gen.html","id":null,"dir":"Reference","previous_headings":"","what":"Generate Synthetic Noise — noise_gen","title":"Generate Synthetic Noise — noise_gen","text":"Generate Synthetic Noise","code":""},{"path":"/reference/noise_gen.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generate Synthetic Noise — noise_gen","text":"","code":"noise_gen(n = 500, type = \"gaussian\", level = 0.01, seed = NULL)"},{"path":"/reference/noise_gen.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generate Synthetic Noise — noise_gen","text":"n Integer. Number samples generate. Default 500. type Character string specifying type noise generate. Supported types: \"gaussian\": Standard normal distribution. \"uniform\": Uniform distribution -level +level. \"lognormal\": Log-normal distribution. \"t_distributed\": Heavy-tailed t-distribution 3 degrees freedom. \"cauchy\": Extremely heavy-tailed Cauchy distribution. \"beta_noise\": Beta distribution shifted scaled [-level, level]. \"exponential\": Positive-exponential distribution. \"microstructure\": Oscillatory sinusoidal pattern additive Gaussian noise. level Numeric. Controls scale (standard deviation, range, spread) noise. Default 0.01. seed Optional integer. Sets random seed reproducibility.","code":""},{"path":"/reference/noise_gen.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generate Synthetic Noise — noise_gen","text":"tibble two columns: value: Numeric vector generated noise samples. type: Character string indicating type noise.","code":""},{"path":"/reference/noise_gen.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generate Synthetic Noise — noise_gen","text":"","code":"# Gaussian noise with small scale noise_gen(500, type = \"gaussian\", level = 0.05) #> # A tibble: 500 × 2 #>       value type     #>       <dbl> <chr>    #>  1  0.0390  gaussian #>  2 -0.00927 gaussian #>  3 -0.0186  gaussian #>  4 -0.0188  gaussian #>  5 -0.0525  gaussian #>  6  0.00678 gaussian #>  7 -0.0521  gaussian #>  8  0.0686  gaussian #>  9  0.0106  gaussian #> 10 -0.0210  gaussian #> # ℹ 490 more rows  # Heavy-tailed noise noise_gen(500, type = \"t_distributed\", level = 0.1) #> # A tibble: 500 × 2 #>       value type          #>       <dbl> <chr>         #>  1 -0.0106  t_distributed #>  2  0.0601  t_distributed #>  3 -0.00778 t_distributed #>  4  0.116   t_distributed #>  5  0.00472 t_distributed #>  6 -0.0952  t_distributed #>  7  0.0545  t_distributed #>  8  0.00486 t_distributed #>  9 -0.0206  t_distributed #> 10 -0.105   t_distributed #> # ℹ 490 more rows"},{"path":"/reference/pipeData.html","id":null,"dir":"Reference","previous_headings":"","what":"Generating a sample of points on a pipe — pipeData","title":"Generating a sample of points on a pipe — pipeData","text":"Points drawn uniform distribution -1 1, pipe structure generated rejecting points circle radius 1 thickness t last two parameters.","code":""},{"path":"/reference/pipeData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generating a sample of points on a pipe — pipeData","text":"","code":"pipeData(n, p, t = 0.1)"},{"path":"/reference/pipeData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generating a sample of points on a pipe — pipeData","text":"n sample dimensionality p number sample points generate t thickness circle, default=0.1","code":""},{"path":"/reference/pipeData.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generating a sample of points on a pipe — pipeData","text":"sample points tibble format","code":""},{"path":"/reference/pipeData.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generating a sample of points on a pipe — pipeData","text":"","code":"pipeData(4, 100) #> New names: #> • `` -> `...1` #> • `` -> `...2` #> • `` -> `...3` #> • `` -> `...4` #> # A tibble: 100 × 4 #>       ...1    ...2    ...3   ...4 #>      <dbl>   <dbl>   <dbl>  <dbl> #>  1 -0.247   0.0945 -0.667  -0.790 #>  2 -0.0730 -0.346   0.471  -0.856 #>  3  0.397   0.701   0.156  -0.959 #>  4  0.158  -0.0337  0.754  -0.618 #>  5 -0.507  -0.324   0.142  -0.980 #>  6  0.103  -0.371   0.366  -0.895 #>  7  0.371  -0.560   0.0596 -0.989 #>  8 -0.311  -0.443  -0.244  -0.996 #>  9 -0.912   0.711  -0.916   0.256 #> 10  0.577   0.777   0.991  -0.140 #> # ℹ 90 more rows pipeData(2, 100, 0.5) #> New names: #> • `` -> `...1` #> • `` -> `...2` #> # A tibble: 100 × 2 #>       ...1   ...2 #>      <dbl>  <dbl> #>  1  0.0482 -0.762 #>  2  0.683  -0.315 #>  3  0.591  -0.575 #>  4 -0.675  -0.292 #>  5  0.187  -0.792 #>  6  0.570  -0.699 #>  7 -0.924  -0.427 #>  8 -0.732   0.820 #>  9  0.170   0.752 #> 10 -0.217  -0.894 #> # ℹ 90 more rows"},{"path":"/reference/pipe_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Generating a sample of points on a pipe — pipe_data","title":"Generating a sample of points on a pipe — pipe_data","text":"Points drawn uniform distribution -1 1, pipe structure generated rejecting points circle radius 1 thickness t last two parameters.","code":""},{"path":"/reference/pipe_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generating a sample of points on a pipe — pipe_data","text":"","code":"pipe_data(n, p, t = 0.1)"},{"path":"/reference/pipe_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generating a sample of points on a pipe — pipe_data","text":"n number sample points generate p sample dimensionality t thickness circle, default=0.1","code":""},{"path":"/reference/pipe_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generating a sample of points on a pipe — pipe_data","text":"sample points tibble format","code":""},{"path":"/reference/pipe_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generating a sample of points on a pipe — pipe_data","text":"","code":"pipe_data(100, 4) #> # A tibble: 100 × 4 #>         V1       V2     V3      V4 #>      <dbl>    <dbl>  <dbl>   <dbl> #>  1 -0.0105  0.408    0.381  0.921  #>  2  0.807  -0.699   -0.948  0.126  #>  3  0.426   0.980   -0.859 -0.410  #>  4 -0.687  -0.00813  0.257 -0.945  #>  5  0.452   0.584    0.705 -0.769  #>  6 -0.745  -0.885   -0.212  0.952  #>  7  0.583  -0.287    0.110  0.951  #>  8  0.281  -0.993    0.523  0.822  #>  9  0.967  -0.0456   0.954 -0.0628 #> 10  0.941   0.292    0.757  0.590  #> # ℹ 90 more rows pipe_data(100, 2, 0.5) #> # A tibble: 100 × 2 #>        V1      V2 #>     <dbl>   <dbl> #>  1  0.834  0.0861 #>  2  0.838 -0.740  #>  3 -0.922  0.556  #>  4  0.607  0.393  #>  5  0.991  0.199  #>  6  0.619 -0.913  #>  7  0.725  0.454  #>  8 -0.642 -0.438  #>  9 -0.586  0.755  #> 10 -0.356 -0.943  #> # ℹ 90 more rows"},{"path":"/reference/plotRotation.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot rotation traces of indexes obtained with profileRotation. — plotRotation","title":"Plot rotation traces of indexes obtained with profileRotation. — plotRotation","text":"Plot rotation traces indexes obtained profileRotation.","code":""},{"path":"/reference/plotRotation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot rotation traces of indexes obtained with profileRotation. — plotRotation","text":"","code":"plotRotation(resMat)"},{"path":"/reference/plotRotation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot rotation traces of indexes obtained with profileRotation. — plotRotation","text":"resMat data (result profileRotation)","code":""},{"path":"/reference/plotRotation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot rotation traces of indexes obtained with profileRotation. — plotRotation","text":"ggplot visualisation tracing data","code":""},{"path":"/reference/plotSmoothingComparison.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the comparison of smoothing methods. — plotSmoothingComparison","title":"Plot the comparison of smoothing methods. — plotSmoothingComparison","text":"Plotting method results compareSmoothing. results mapped facetting values alpha mapping method (jitterAngle, jitterPoints, noSmoothing) linestyle color (black dashed, black dotted, red solid). default legend drawing turned , can turned via lPos argument, e.g. setting \"bottom\" legend plot.","code":""},{"path":"/reference/plotSmoothingComparison.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the comparison of smoothing methods. — plotSmoothingComparison","text":"","code":"plotSmoothingComparison(smMat, lPos = \"none\")"},{"path":"/reference/plotSmoothingComparison.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the comparison of smoothing methods. — plotSmoothingComparison","text":"smMat Result compareSmoothing lPos Legend position passed ggplot2 (default none legend shown)","code":""},{"path":"/reference/plotSmoothingComparison.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the comparison of smoothing methods. — plotSmoothingComparison","text":"ggplot visualisation comparison","code":""},{"path":"/reference/plotTrace.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot traces of indexes obtained with getTrace. — plotTrace","title":"Plot traces of indexes obtained with getTrace. — plotTrace","text":"Plot traces indexes obtained getTrace.","code":""},{"path":"/reference/plotTrace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot traces of indexes obtained with getTrace. — plotTrace","text":"","code":"plotTrace(resMat, rescY = TRUE)"},{"path":"/reference/plotTrace.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot traces of indexes obtained with getTrace. — plotTrace","text":"resMat data (result getTrace) rescY bool fix y axis range [0,1]","code":""},{"path":"/reference/plotTrace.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot traces of indexes obtained with getTrace. — plotTrace","text":"ggplot visualisation tracing data","code":""},{"path":"/reference/plot_rotation.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot rotation traces of indexes obtained with profileRotation. — plot_rotation","title":"Plot rotation traces of indexes obtained with profileRotation. — plot_rotation","text":"Plot rotation traces indexes obtained profileRotation.","code":""},{"path":"/reference/plot_rotation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot rotation traces of indexes obtained with profileRotation. — plot_rotation","text":"","code":"plot_rotation(res_mat)"},{"path":"/reference/plot_rotation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot rotation traces of indexes obtained with profileRotation. — plot_rotation","text":"res_mat data (result profileRotation)","code":""},{"path":"/reference/plot_rotation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot rotation traces of indexes obtained with profileRotation. — plot_rotation","text":"ggplot visualisation tracing data","code":""},{"path":"/reference/plot_smoothing_comparison.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot the comparison of smoothing methods. — plot_smoothing_comparison","title":"Plot the comparison of smoothing methods. — plot_smoothing_comparison","text":"Plotting method results compareSmoothing. results mapped facetting values alpha mapping method (jitter_angle, jitter_points, no_smoothing) linestyle color (black dashed, black dotted, red solid). default legend drawing turned , can turned via lPos argument, e.g. setting \"bottom\" legend plot.","code":""},{"path":"/reference/plot_smoothing_comparison.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot the comparison of smoothing methods. — plot_smoothing_comparison","text":"","code":"plot_smoothing_comparison(sm_mat, lPos = \"none\")"},{"path":"/reference/plot_smoothing_comparison.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot the comparison of smoothing methods. — plot_smoothing_comparison","text":"sm_mat Result compare_smoothing lPos Legend position passed ggplot2 (default none legend shown)","code":""},{"path":"/reference/plot_smoothing_comparison.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot the comparison of smoothing methods. — plot_smoothing_comparison","text":"ggplot visualisation comparison","code":""},{"path":"/reference/plot_trace.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot traces of indexes obtained with get_trace. — plot_trace","title":"Plot traces of indexes obtained with get_trace. — plot_trace","text":"Plot traces indexes obtained get_trace.","code":""},{"path":"/reference/plot_trace.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot traces of indexes obtained with get_trace. — plot_trace","text":"","code":"plot_trace(res_mat, rescY = TRUE)"},{"path":"/reference/plot_trace.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot traces of indexes obtained with get_trace. — plot_trace","text":"res_mat data (result get_trace) rescY bool fix y axis range [0,1]","code":""},{"path":"/reference/plot_trace.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot traces of indexes obtained with get_trace. — plot_trace","text":"ggplot visualisation tracing data","code":""},{"path":"/reference/ppi_mean.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate and Summarize Projection Pursuit Index (PPI) Values — ppi_mean","title":"Simulate and Summarize Projection Pursuit Index (PPI) Values — ppi_mean","text":"Simulate Summarize Projection Pursuit Index (PPI) Values","code":""},{"path":"/reference/ppi_mean.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate and Summarize Projection Pursuit Index (PPI) Values — ppi_mean","text":"","code":"ppi_mean(data, index_fun, n_sim = 100, n_obs = 300)"},{"path":"/reference/ppi_mean.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate and Summarize Projection Pursuit Index (PPI) Values — ppi_mean","text":"data data frame matrix. Must least two columns. index_fun function taking two numeric vectors (x, y) returning scalar index. n_sim Integer. Number simulations. Default 100. n_obs Integer. Number observations sample simulation. Default 300.","code":""},{"path":"/reference/ppi_mean.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate and Summarize Projection Pursuit Index (PPI) Values — ppi_mean","text":"tibble : var_i, var_j: Names variable pairs mean_index: Mean index value simulations","code":""},{"path":"/reference/ppi_mean.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate and Summarize Projection Pursuit Index (PPI) Values — ppi_mean","text":"","code":"data <- as.data.frame(data_gen(type = \"polynomial\", degree = 2)) ppi_mean(data, scag_index(\"stringy\"), n_sim = 10) #> # A tibble: 1 × 3 #>   var_i var_j mean_index #>   <chr> <chr>      <dbl> #> 1 1     2              1"},{"path":"/reference/ppi_noise_threshold.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate the 95th Percentile of a Projection Pursuit Index Under Noise — ppi_noise_threshold","title":"Estimate the 95th Percentile of a Projection Pursuit Index Under Noise — ppi_noise_threshold","text":"function estimates 95th percentile projection pursuit index synthetic noise data.","code":""},{"path":"/reference/ppi_noise_threshold.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate the 95th Percentile of a Projection Pursuit Index Under Noise — ppi_noise_threshold","text":"","code":"ppi_noise_threshold(   index_fun,   n_sim = 100,   n_obs = 500,   noise_type = \"gaussian\",   noise_level = 0.01,   seed = NULL )"},{"path":"/reference/ppi_noise_threshold.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate the 95th Percentile of a Projection Pursuit Index Under Noise — ppi_noise_threshold","text":"index_fun function takes either 2-column matrix two numeric vectors returns scalar index. n_sim Integer. Number index evaluations simulate. Default 100. n_obs Integer. Number observations per noise sample. Default 500. noise_type Character. Type noise use (e.g., \"gaussian\", \"t_distributed\", etc.). Default \"gaussian\". noise_level Numeric. Controls scale/spread generated noise. Default 0.01. seed Optional integer. Random seed reproducibility.","code":""},{"path":"/reference/ppi_noise_threshold.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate the 95th Percentile of a Projection Pursuit Index Under Noise — ppi_noise_threshold","text":"single numeric value: estimated 95th percentile index noise.","code":""},{"path":"/reference/ppi_noise_threshold.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate the 95th Percentile of a Projection Pursuit Index Under Noise — ppi_noise_threshold","text":"","code":"ppi_noise_threshold(   index_fun = scag_index(\"stringy\"),   noise_type = \"cauchy\",   noise_level = 0.1,   n_sim = 10,   n_obs = 100 ) #>       95%  #> 0.7667706"},{"path":"/reference/ppi_samplesize_effect.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate Effect of Sample Size on Projection Pursuit Index Under Gaussian Noise — ppi_samplesize_effect","title":"Simulate Effect of Sample Size on Projection Pursuit Index Under Gaussian Noise — ppi_samplesize_effect","text":"given index function, simulates index behaves across range sample sizes applied pairs standard normal noise.","code":""},{"path":"/reference/ppi_samplesize_effect.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate Effect of Sample Size on Projection Pursuit Index Under Gaussian Noise — ppi_samplesize_effect","text":"","code":"ppi_samplesize_effect(index_fun, n_sim = 100)"},{"path":"/reference/ppi_samplesize_effect.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate Effect of Sample Size on Projection Pursuit Index Under Gaussian Noise — ppi_samplesize_effect","text":"index_fun function taking two numeric vectors (x, y) returning scalar index. n_sim Integer. Number simulations per sample size. Default 100.","code":""},{"path":"/reference/ppi_samplesize_effect.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate Effect of Sample Size on Projection Pursuit Index Under Gaussian Noise — ppi_samplesize_effect","text":"tibble : sample_size: sample size used simulation block percentile95: 95th percentile index values simulations","code":""},{"path":"/reference/ppi_samplesize_effect.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate Effect of Sample Size on Projection Pursuit Index Under Gaussian Noise — ppi_samplesize_effect","text":"","code":"ppi_samplesize_effect(scag_index(\"stringy\"), n_sim = 10) #> # A tibble: 125 × 2 #>    sample_size percentile95 #>          <dbl>        <dbl> #>  1          30        0.773 #>  2          35        0.815 #>  3          40        0.871 #>  4          45        0.794 #>  5          50        0.795 #>  6          55        0.788 #>  7          60        0.770 #>  8          65        0.793 #>  9          70        0.763 #> 10          75        0.770 #> # ℹ 115 more rows"},{"path":"/reference/ppi_scale.html","id":null,"dir":"Reference","previous_headings":"","what":"Simulate and Compare Index Scale on Structured vs Noisy Data — ppi_scale","title":"Simulate and Compare Index Scale on Structured vs Noisy Data — ppi_scale","text":"Performs simulations compute projection pursuit index structured (sampled) data random noise, allowing comparison index scale across contexts.","code":""},{"path":"/reference/ppi_scale.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simulate and Compare Index Scale on Structured vs Noisy Data — ppi_scale","text":"","code":"ppi_scale(data, index_fun, n_sim = 100, n_obs = 500, seed = NULL)"},{"path":"/reference/ppi_scale.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simulate and Compare Index Scale on Structured vs Noisy Data — ppi_scale","text":"data data frame tibble least two numeric columns. index_fun function takes two numeric vectors (x, y) returns numeric scalar index. n_sim Integer. Number simulations. Default 100. n_obs Integer. Number observations per simulation. Default 500. seed Optional integer seed reproducibility.","code":""},{"path":"/reference/ppi_scale.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simulate and Compare Index Scale on Structured vs Noisy Data — ppi_scale","text":"tibble columns: simulation: simulation number var_i, var_j: variable names var_pair: pair name string sigma: 0 structured data, 1 noisy data index: index value returned index_fun","code":""},{"path":"/reference/ppi_scale.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simulate and Compare Index Scale on Structured vs Noisy Data — ppi_scale","text":"","code":"ppi_scale(data_gen(\"polynomial\", degree = 3), scag_index(\"stringy\"), n_sim = 10) #> # A tibble: 60 × 6 #>    simulation var_i var_j var_pair sigma index #>         <int> <chr> <chr> <chr>    <dbl> <dbl> #>  1          1 1     2     1-2          0 1     #>  2          1 1     2     1-2          1 0.708 #>  3          1 1     3     1-3          0 1     #>  4          1 1     3     1-3          1 0.743 #>  5          1 2     3     2-3          0 0.996 #>  6          1 2     3     2-3          1 0.743 #>  7          2 1     2     1-2          0 1     #>  8          2 1     2     1-2          1 0.687 #>  9          2 1     3     1-3          0 1     #> 10          2 1     3     1-3          1 0.720 #> # ℹ 50 more rows"},{"path":"/reference/profileRotation.html","id":null,"dir":"Reference","previous_headings":"","what":"Test rotation invariance of index functions for selected 2-d data set. — profileRotation","title":"Test rotation invariance of index functions for selected 2-d data set. — profileRotation","text":"Ideally projection pursuit index roation invariant, test explicitly profiling index rotating distribution.","code":""},{"path":"/reference/profileRotation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test rotation invariance of index functions for selected 2-d data set. — profileRotation","text":"","code":"profileRotation(d, indexList, indexLabels, n = 200)"},{"path":"/reference/profileRotation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test rotation invariance of index functions for selected 2-d data set. — profileRotation","text":"d data (2 column matrix containing distribution rotated) indexList list index functions calculate entry indexLabels labels used output n number steps rotation (default = 200)","code":""},{"path":"/reference/profileRotation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test rotation invariance of index functions for selected 2-d data set. — profileRotation","text":"index values rotation step","code":""},{"path":"/reference/profileRotation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test rotation invariance of index functions for selected 2-d data set. — profileRotation","text":"","code":"d <- as.matrix(sinData(2, 30)) #> New names: #> • `` -> `...1` #> • `` -> `...2` indexList <- list(tourr::holes(), scagIndex(\"stringy\"), mineIndexE(\"MIC\")) indexLabels <- c(\"holes\", \"stringy\", \"mic\") pRot <- profileRotation(d, indexList, indexLabels, n = 50) plotRotation(pRot)"},{"path":"/reference/profile_rotation.html","id":null,"dir":"Reference","previous_headings":"","what":"Test rotation invariance of index functions for selected 2-d data set. — profile_rotation","title":"Test rotation invariance of index functions for selected 2-d data set. — profile_rotation","text":"Ideally projection pursuit index roation invariant, test explicitly profiling index rotating distribution.","code":""},{"path":"/reference/profile_rotation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Test rotation invariance of index functions for selected 2-d data set. — profile_rotation","text":"","code":"profile_rotation(d, index_list, index_labels, n = 200)"},{"path":"/reference/profile_rotation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Test rotation invariance of index functions for selected 2-d data set. — profile_rotation","text":"d data (2 column matrix containing distribution rotated) index_list list index functions calculate entry index_labels labels used output n number steps rotation (default = 200)","code":""},{"path":"/reference/profile_rotation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Test rotation invariance of index functions for selected 2-d data set. — profile_rotation","text":"index values rotation step","code":""},{"path":"/reference/profile_rotation.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Test rotation invariance of index functions for selected 2-d data set. — profile_rotation","text":"","code":"d <- as.matrix(sin_data(30, 2)) index_list <- list(tourr::holes(), scag_index(\"stringy\"), mine_indexE(\"MIC\")) index_labels <- c(\"holes\", \"stringy\", \"mic\") pRot <- profile_rotation(d, index_list, index_labels, n = 50) plot_rotation(pRot)"},{"path":"/reference/scagIndex.html","id":null,"dir":"Reference","previous_headings":"","what":"Matching index functions to the required format. — scagIndex","title":"Matching index functions to the required format. — scagIndex","text":"convenicence functions format scagnostics mine index functions direct use guided tour functionalities package.","code":""},{"path":"/reference/scagIndex.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Matching index functions to the required format. — scagIndex","text":"","code":"scagIndex(indexName)  mineIndex(indexName)  mineIndexE(indexName)  holesR()  cmassR()"},{"path":"/reference/scagIndex.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Matching index functions to the required format. — scagIndex","text":"indexName Index name select group indexes.","code":""},{"path":"/reference/scagIndex.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Matching index functions to the required format. — scagIndex","text":"function taking 2-d data matrix returning index value","code":""},{"path":"/reference/scagIndex.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Matching index functions to the required format. — scagIndex","text":"scagIndex(): Scagnostics index binostics package mineIndex(): MINE index minerva package mineIndexE(): MINE index minerva package (updated estimator) holesR(): rescaling tourr holes index cmassR(): rescaling tourr cmass index","code":""},{"path":"/reference/scag_index.html","id":null,"dir":"Reference","previous_headings":"","what":"Matching index functions to the required format. — scag_index","title":"Matching index functions to the required format. — scag_index","text":"convenicence functions format scagnostics mine index functions direct use guided tour functionalities package.","code":""},{"path":"/reference/scag_index.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Matching index functions to the required format. — scag_index","text":"","code":"scag_index(index_name)  mine_index(index_name)  mine_indexE(index_name)  holesR()  cmassR()"},{"path":"/reference/scag_index.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Matching index functions to the required format. — scag_index","text":"index_name Index name select group indexes.","code":""},{"path":"/reference/scag_index.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Matching index functions to the required format. — scag_index","text":"function taking 2-d data matrix returning index value","code":""},{"path":"/reference/scag_index.html","id":"functions","dir":"Reference","previous_headings":"","what":"Functions","title":"Matching index functions to the required format. — scag_index","text":"scag_index(): Scagnostics index cassowaryr package mine_index(): MINE index minerva package mine_indexE(): MINE index minerva package (updated estimator) holesR(): rescaling tourr holes index cmassR(): rescaling tourr cmass index","code":""},{"path":"/reference/sinData.html","id":null,"dir":"Reference","previous_headings":"","what":"Generating sine wave sample — sinData","title":"Generating sine wave sample — sinData","text":"n-1 points drawn normal distribution mean=0, sd=1, points final direction calculated sine values direction n-1 additional jittering controled jitter factor f.","code":""},{"path":"/reference/sinData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generating sine wave sample — sinData","text":"","code":"sinData(n, p, f = 1)"},{"path":"/reference/sinData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generating sine wave sample — sinData","text":"n sample dimensionality p number sample points generate f jitter factor, default=1","code":""},{"path":"/reference/sinData.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generating sine wave sample — sinData","text":"sample points tibble format","code":""},{"path":"/reference/sinData.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generating sine wave sample — sinData","text":"","code":"sinData(4, 100) #> New names: #> • `` -> `...1` #> • `` -> `...2` #> • `` -> `...3` #> • `` -> `...4` #> # A tibble: 100 × 4 #>      ...1    ...2   ...3   ...4 #>     <dbl>   <dbl>  <dbl>  <dbl> #>  1 -0.314  2.00   -0.652 -0.607 #>  2 -1.29  -0.382   0.810  0.725 #>  3  0.117 -1.67    0.721  0.660 #>  4  1.39  -0.420   0.802  0.719 #>  5 -0.182  0.435  -1.01  -0.848 #>  6 -0.668  2.18    1.02   0.851 #>  7  1.25  -0.0606  0.525  0.501 #>  8 -0.572 -0.196   0.729  0.667 #>  9  0.345  0.513  -0.174 -0.173 #> 10 -0.461 -0.0379  0.945  0.810 #> # ℹ 90 more rows sinData(2, 100, 200) #> New names: #> • `` -> `...1` #> • `` -> `...2` #> # A tibble: 100 × 2 #>       ...1    ...2 #>      <dbl>   <dbl> #>  1  1.48    1.00   #>  2  0.734   0.681  #>  3 -2.57   -0.544  #>  4  0.242   0.201  #>  5 -0.0139  0.0103 #>  6 -1.10   -0.887  #>  7 -0.161  -0.144  #>  8  0.763   0.675  #>  9  1.72    0.982  #> 10  0.236   0.259  #> # ℹ 90 more rows"},{"path":"/reference/sin_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Generating sine wave sample — sin_data","title":"Generating sine wave sample — sin_data","text":"n-1 points drawn normal distribution mean=0, sd=1, points final direction calculated sine values direction n-1 additional jittering controled jitter factor f.","code":""},{"path":"/reference/sin_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generating sine wave sample — sin_data","text":"","code":"sin_data(n, p, f = 1)"},{"path":"/reference/sin_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generating sine wave sample — sin_data","text":"n number sample points generate p sample dimensionality f jitter factor, default=1","code":""},{"path":"/reference/sin_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generating sine wave sample — sin_data","text":"sample points tibble format","code":""},{"path":"/reference/sin_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generating sine wave sample — sin_data","text":"","code":"sin_data(100, 4) #> # A tibble: 100 × 4 #>         V1      V2      V3      V4 #>      <dbl>   <dbl>   <dbl>   <dbl> #>  1  0.987   0.547  -0.825  -0.735  #>  2  0.363   1.53    0.458   0.442  #>  3 -0.461   1.44    0.639   0.596  #>  4  1.20    0.534   0.461   0.444  #>  5 -0.405  -1.42    0.155   0.154  #>  6  0.475  -0.0183  0.0975  0.0974 #>  7  0.583  -0.991  -0.315  -0.310  #>  8  0.0622  0.393  -1.16   -0.916  #>  9  0.914   0.886  -0.474  -0.457  #> 10 -0.899  -0.907   1.01    0.844  #> # ℹ 90 more rows sin_data(100, 2, 200) #> # A tibble: 100 × 2 #>        V1     V2 #>     <dbl>  <dbl> #>  1 -0.383 -0.397 #>  2  0.456  0.422 #>  3  0.583  0.520 #>  4  0.575  0.540 #>  5 -0.922 -0.765 #>  6 -0.172 -0.207 #>  7 -1.52  -1.01  #>  8  0.182  0.207 #>  9  1.30   0.998 #> 10 -0.636 -0.595 #> # ℹ 90 more rows"},{"path":"/reference/spinebil-package.html","id":null,"dir":"Reference","previous_headings":"","what":"spinebil — spinebil-package","title":"spinebil — spinebil-package","text":"Functions evaluate performance projection pursuit index functions using tour methods.","code":""},{"path":[]},{"path":"/reference/spinebil-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"spinebil — spinebil-package","text":"Maintainer: Tina Rashid Jafari tina.rashidjafari@gmail.com (ORCID) Authors: Ursula Laa ursula.laa@boku.ac.(ORCID) Dianne Cook dicook@monash.edu (ORCID)","code":""},{"path":"/reference/spiralData.html","id":null,"dir":"Reference","previous_headings":"","what":"Generating spiral sample — spiralData","title":"Generating spiral sample — spiralData","text":"n-2 points drawn normal distribution mean=0, sd=1, points final two direction sampled along spiral samping angle normal distribution mean=0, sd=2*pi (absolute values used fix orientation spiral).","code":""},{"path":"/reference/spiralData.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generating spiral sample — spiralData","text":"","code":"spiralData(n, p)"},{"path":"/reference/spiralData.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generating spiral sample — spiralData","text":"n sample dimensionality p number sample points generate","code":""},{"path":"/reference/spiralData.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generating spiral sample — spiralData","text":"sample points matrix format","code":""},{"path":"/reference/spiralData.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generating spiral sample — spiralData","text":"","code":"spiralData(4, 100) #>           [,1]         [,2]         [,3]         [,4] #> v  0.895414770 -0.083443880  0.043714283  0.879345122 #> v  0.071710106  0.381153132 -0.110503754 -0.539855101 #> v -1.208123013  1.070491316 -0.958322124  0.319788089 #> v -0.355679369 -0.607559598  1.257445230 -0.416559948 #> v  1.698005341 -0.738201192  0.689241018 -0.154281265 #> v  0.242499160 -0.815162137 -0.392795408 -0.264170926 #> v -0.800868011 -0.624816542 -1.119438979  1.131557781 #> v -0.715843977 -1.270220440 -0.027219800  0.888045276 #> v -0.257891448 -3.679007212 -0.364455165  0.117578399 #> v -1.347365506 -0.219303683 -0.687680838 -0.902235814 #> v  1.300838235 -0.081009412 -0.406327633 -0.225895436 #> v -0.760981191  0.598869689 -0.162441574 -0.515749577 #> v -0.798239439 -1.854334763 -0.109341699 -0.540319602 #> v -0.131468357 -0.275069062  0.157950704  0.852571635 #> v -0.288595190  1.239788854  0.126778885  0.124314499 #> v -2.094046724 -1.119598880  0.996111385 -0.816481457 #> v  0.340152799 -0.071719307  0.589029431 -0.333357754 #> v  1.824705023 -0.355623825  0.775033615  1.234538191 #> v -0.848446432  1.851398173  0.080247943  0.204504477 #> v -0.436746841 -0.406965380 -0.348961565  0.855700739 #> v -1.094729165 -0.373391575  0.503665694 -0.423963642 #> v -0.598744490 -0.687464324  0.246711514 -0.560814894 #> v  1.915922545 -0.091923142  0.192228008 -0.572222765 #> v  0.056954758 -0.332564397  0.552406464 -0.376477272 #> v  0.711169746 -0.041989329  0.120937931  0.142029728 #> v -0.555164755  0.288005112 -0.030746685  0.266787882 #> v  1.018037114  0.211094863 -0.066874629  0.273029573 #> v  0.365928319 -1.396460628  0.113142974  0.016304110 #> v -0.910517697  0.386489849  0.114113712  0.017828309 #> v -0.804496233 -0.166540862  0.425986281 -0.482414999 #> v -0.536234042 -0.185539382  0.026861009  0.244675172 #> v -0.294871345  0.707342896 -0.028410444  0.266200200 #> v  0.569362231 -1.043773591 -0.791177363  0.577352105 #> v -1.093359385 -2.964031913  0.132119227  0.088473296 #> v  1.897274942  1.249561489 -0.388118996  0.074477765 #> v  0.780582140 -2.012543530  0.132049273  0.090448695 #> v  0.509920643 -0.725138620  0.115757679  0.153933931 #> v -0.419696344  0.659925163  0.183047069 -0.573630239 #> v -0.664609851  0.521602156 -0.404486599  0.033574780 #> v  0.093885864 -0.752119179 -0.264443349  0.220899038 #> v -0.812580829 -1.155860853 -0.035334848 -0.563874611 #> v  0.600409023  0.101221234  0.049228439 -0.577646708 #> v  0.341127654  0.683741185  0.124766999  0.039994443 #> v -0.291531797 -1.388678100 -0.199827160  0.254569238 #> v  0.030633075 -0.249335058  0.572436605 -0.353818256 #> v -0.036688552 -0.130230355  0.112531653  0.015372801 #> v -1.594664359 -2.434916235 -0.259710322 -0.449127592 #> v -0.135360703 -2.523981771  0.458277695 -0.460329937 #> v  0.908689684  1.631233186 -0.308115023 -0.401030198 #> v -0.115632837 -0.890795496 -0.380409315 -0.292154608 #> v  0.910630913 -0.029664633 -0.292590668  0.199730655 #> v -0.063772035  1.468654127 -0.720050242 -0.871535124 #> v  0.255570223  0.024299091  0.096555459  0.185443476 #> v  1.589806608  0.948880032 -0.425307322 -0.080333429 #> v -1.324115477 -1.603107928 -0.239724646 -1.154456315 #> v  0.252915526 -0.203602189 -0.310025593  0.184107557 #> v -0.086544252 -0.259015582 -0.060437756 -0.557165417 #> v -0.715312421  0.731111456 -0.174537223 -0.509126430 #> v  0.937127434 -1.015356369  0.092451394  0.190713819 #> v  1.103117171  0.292140255  1.150254435 -0.620908577 #> v  0.764505697 -0.377514384 -0.425540173 -0.107292102 #> v  1.388600824 -0.424895077 -0.218770505  0.246591555 #> v -1.419396315  0.692795974  1.222390685  0.700030771 #> v -0.003858885 -0.871392046 -0.020470609 -0.567262560 #> v -0.259155608 -1.473526736 -0.570458423  0.759434143 #> v -0.216946324 -0.471020663 -0.371547822  0.105991693 #> v -0.971953648  0.844885266 -0.390368998  0.069577180 #> v -0.533805581  0.926368708 -0.298061239  0.195055285 #> v -1.575998241  0.958101944  0.114916525  0.019133391 #> v  0.278616729  0.939134624 -0.320654075 -0.386168751 #> v  0.556841494 -0.642014236 -0.360555690 -0.329050209 #> v  0.749577500 -0.548980021  0.094568099  0.188041707 #> v  2.076907498  0.131077511 -0.252131289 -0.455575701 #> v  1.305320690  0.007253685 -0.361808624 -0.326936638 #> v  1.668426736 -1.316765063  0.713899372 -0.075094832 #> v  0.955897056  0.578969677  0.110357954  0.012225510 #> v -1.864518981  0.078841083 -0.177483260  0.262163763 #> v -0.145291622 -0.463711175  0.654189514  0.438084298 #> v  0.024409177 -0.890439725  0.087780892  0.196294836 #> v -0.516747178  0.398999144  0.727707153 -0.004354291 #> v -0.319483584 -0.639762156 -0.812840087  0.552413770 #> v -0.436491649  0.303567608  0.543189171  0.603743057 #> v  0.215418682  0.209324028 -0.016473852  0.262823681 #> v  0.558972939 -0.521812892  0.455020990 -0.462690907 #> v -0.323846498  0.436659883  0.724607262 -0.024017502 #> v  2.692515039 -1.861033697  0.605022164  0.522752936 #> v  0.737202133  1.518832777  0.115695657 -0.579508114 #> v  0.725283091  0.648490725 -0.380948457  0.845889720 #> v -0.110312948  1.444280315 -0.008081274  0.260060561 #> v -0.012173077 -1.588928185 -0.419780918 -0.027382351 #> v -0.354420614  0.420952386  0.473647577  0.674479720 #> v -0.445451455 -0.086206632  0.649772201 -0.240535100 #> v -0.677462097 -0.824404203  0.126039314  0.126975854 #> v -1.995084156 -1.239298910  0.091606825  0.191754112 #> v -0.816230818  1.020711732 -1.041451598 -0.209640097 #> v  1.154428245 -0.051759966 -0.055568076  0.271632737 #> v -0.303187060  0.156827019 -0.181757678  0.260857897 #> v  0.996510324 -1.901515646 -0.385304257  0.080365900 #> v  1.322971167 -1.826342700 -0.190943591 -0.499470061 #> v -1.276119338  0.983569482  1.274793843 -0.372800058"},{"path":"/reference/spiral_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Generating spiral sample — spiral_data","title":"Generating spiral sample — spiral_data","text":"n-2 points drawn normal distribution mean=0, sd=1, points final two direction sampled along spiral samping angle normal distribution mean=0, sd=2*pi (absolute values used fix orientation spiral).","code":""},{"path":"/reference/spiral_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Generating spiral sample — spiral_data","text":"","code":"spiral_data(n, p)"},{"path":"/reference/spiral_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Generating spiral sample — spiral_data","text":"n number sample points generate p sample dimensionality","code":""},{"path":"/reference/spiral_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Generating spiral sample — spiral_data","text":"sample points matrix format","code":""},{"path":"/reference/spiral_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Generating spiral sample — spiral_data","text":"","code":"spiral_data(100, 4) #> # A tibble: 100 × 4 #>         V1      V2     V3       V4 #>      <dbl>   <dbl>  <dbl>    <dbl> #>  1  1.72   -0.453   0.105  0.173   #>  2  1.63    0.158   0.118  0.0253  #>  3  0.0820  1.06   -0.280 -1.79    #>  4 -0.117   0.796   0.167 -0.576   #>  5  0.125  -0.346  -0.407  0.0265  #>  6  0.0369  0.944  -0.426 -0.102   #>  7 -0.201   0.0305  0.124  0.0385  #>  8  1.59    1.10   -0.387 -1.10    #>  9 -1.48    0.0200  0.729  0.00821 #> 10 -1.20    0.633   0.104  0.175   #> # ℹ 90 more rows"},{"path":"/reference/squintAngleEstimate.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimating squint angle of 2-d structure in high-d dataset under selected index. — squintAngleEstimate","title":"Estimating squint angle of 2-d structure in high-d dataset under selected index. — squintAngleEstimate","text":"estimate squint angle interpolating random starting plane towards optimal view index value selected index function selected cutoff. Since depends direction, repeated n randomly selected planes giving distribution representative squint angle.","code":""},{"path":"/reference/squintAngleEstimate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimating squint angle of 2-d structure in high-d dataset under selected index. — squintAngleEstimate","text":"","code":"squintAngleEstimate(   data,   indexF,   cutoff,   structurePlane,   n = 100,   stepSize = 0.01 )"},{"path":"/reference/squintAngleEstimate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimating squint angle of 2-d structure in high-d dataset under selected index. — squintAngleEstimate","text":"data Input data indexF Index function cutoff Threshold index value assume structure visible structurePlane Plane defining optimal view n Number random starting planes (default = 100) stepSize Interpolation step size fixing accuracy (default = 0.01)","code":""},{"path":"/reference/squintAngleEstimate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimating squint angle of 2-d structure in high-d dataset under selected index. — squintAngleEstimate","text":"numeric vector containing squint angle estimates","code":""},{"path":"/reference/squintAngleEstimate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimating squint angle of 2-d structure in high-d dataset under selected index. — squintAngleEstimate","text":"","code":"data <- spiralData(4, 50) indexF <- scagIndex(\"stringy\") cutoff <- 0.7 structurePlane <- basisMatrix(3,4,4) squintAngleEstimate(data, indexF, cutoff, structurePlane, n=1) #> [1] 0.844061"},{"path":"/reference/squint_angle_estimate.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimating squint angle of 2-d structure in high-d dataset under selected index. — squint_angle_estimate","title":"Estimating squint angle of 2-d structure in high-d dataset under selected index. — squint_angle_estimate","text":"estimate squint angle interpolating random starting plane towards optimal view index value selected index function selected cutoff. Since depends direction, repeated n randomly selected planes giving distribution representative squint angle.","code":""},{"path":"/reference/squint_angle_estimate.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimating squint angle of 2-d structure in high-d dataset under selected index. — squint_angle_estimate","text":"","code":"squint_angle_estimate(   data,   indexF,   cutoff,   structure_plane,   n = 100,   step_size = 0.01 )"},{"path":"/reference/squint_angle_estimate.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimating squint angle of 2-d structure in high-d dataset under selected index. — squint_angle_estimate","text":"data Input data indexF Index function cutoff Threshold index value assume structure visible structure_plane Plane defining optimal view n Number random starting planes (default = 100) step_size Interpolation step size fixing accuracy (default = 0.01)","code":""},{"path":"/reference/squint_angle_estimate.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimating squint angle of 2-d structure in high-d dataset under selected index. — squint_angle_estimate","text":"numeric vector containing squint angle estimates","code":""},{"path":"/reference/squint_angle_estimate.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimating squint angle of 2-d structure in high-d dataset under selected index. — squint_angle_estimate","text":"","code":"data <- spiral_data(50, 4) indexF <- scag_index(\"stringy\") cutoff <- 0.7 structure_plane <- basis_matrix(3,4,4) squint_angle_estimate(data, indexF, cutoff, structure_plane, n=1) #> [1] 1.436259"},{"path":"/reference/step_fraction.html","id":null,"dir":"Reference","previous_headings":"","what":"Step along an interpolated path by fraction of path length. — step_fraction","title":"Step along an interpolated path by fraction of path length. — step_fraction","text":"Step along interpolated path fraction path length.","code":""},{"path":"/reference/step_fraction.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Step along an interpolated path by fraction of path length. — step_fraction","text":"","code":"step_fraction(interp, fraction)"},{"path":"/reference/step_fraction.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Step along an interpolated path by fraction of path length. — step_fraction","text":"interp interpolated path fraction fraction distance start end planes","code":""},{"path":"/reference/timeSequence.html","id":null,"dir":"Reference","previous_headings":"","what":"Time each index evaluation for projections in the tour path. — timeSequence","title":"Time each index evaluation for projections in the tour path. — timeSequence","text":"Index evaluation timing may depend data distribution, evaluate computing time set different projections get overview distribution computing times.","code":""},{"path":"/reference/timeSequence.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Time each index evaluation for projections in the tour path. — timeSequence","text":"","code":"timeSequence(d, t, idx, pmax)"},{"path":"/reference/timeSequence.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Time each index evaluation for projections in the tour path. — timeSequence","text":"d Input data matrix format t List projection matrices (e.g. interpolated tour path) idx Index function pmax Maximum number projections evaluate (cut t longer pmax)","code":""},{"path":"/reference/timeSequence.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Time each index evaluation for projections in the tour path. — timeSequence","text":"numeric vector containing distances","code":""},{"path":"/reference/timeSequence.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Time each index evaluation for projections in the tour path. — timeSequence","text":"","code":"d <- spiralData(4, 500) t <- purrr::map(1:10, ~ tourr::basis_random(4)) idx <- scagIndex(\"stringy\") timeSequence(d, t, idx, 10) #>        t  i #> 1  0.045  1 #> 2  0.048  2 #> 3  0.047  3 #> 4  0.047  4 #> 5  0.049  5 #> 6  0.056  6 #> 7  0.049  7 #> 8  0.048  8 #> 9  0.056  9 #> 10 0.053 10"},{"path":"/reference/time_sequence.html","id":null,"dir":"Reference","previous_headings":"","what":"Time each index evaluation for projections in the tour path. — time_sequence","title":"Time each index evaluation for projections in the tour path. — time_sequence","text":"Index evaluation timing may depend data distribution, evaluate computing time set different projections get overview distribution computing times.","code":""},{"path":"/reference/time_sequence.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Time each index evaluation for projections in the tour path. — time_sequence","text":"","code":"time_sequence(d, t, idx, pmax)"},{"path":"/reference/time_sequence.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Time each index evaluation for projections in the tour path. — time_sequence","text":"d Input data matrix format t List projection matrices (e.g. interpolated tour path) idx Index function pmax Maximum number projections evaluate (cut t longer pmax)","code":""},{"path":"/reference/time_sequence.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Time each index evaluation for projections in the tour path. — time_sequence","text":"numeric vector containing distances","code":""},{"path":"/reference/time_sequence.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Time each index evaluation for projections in the tour path. — time_sequence","text":"","code":"d <- spiral_data(500, 4) t <- purrr::map(1:10, ~ tourr::basis_random(4)) idx <- scag_index(\"stringy\") time_sequence(d, t, idx, 10) #> Error in d %*% pMatrix: requires numeric/complex matrix/vector arguments"}]
